// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: events.sql

package store

import (
	"context"
	"database/sql"
	"time"
)

const countEvents = `-- name: CountEvents :one
SELECT COUNT(*) FROM events
`

func (q *Queries) CountEvents(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEvents)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEventsByCategory = `-- name: CountEventsByCategory :one
SELECT COUNT(*) FROM events WHERE category = ?
`

func (q *Queries) CountEventsByCategory(ctx context.Context, category string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEventsByCategory, category)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEventsByLevel = `-- name: CountEventsByLevel :one
SELECT COUNT(*) FROM events WHERE level = ?
`

func (q *Queries) CountEventsByLevel(ctx context.Context, level string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEventsByLevel, level)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEventsByLevelAndCategory = `-- name: CountEventsByLevelAndCategory :one
SELECT COUNT(*) FROM events WHERE level = ? AND category = ?
`

type CountEventsByLevelAndCategoryParams struct {
	Level    string `json:"level"`
	Category string `json:"category"`
}

func (q *Queries) CountEventsByLevelAndCategory(ctx context.Context, arg CountEventsByLevelAndCategoryParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEventsByLevelAndCategory, arg.Level, arg.Category)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (level, category, message, user_id, metadata, ip_address, request_url, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, level, category, message, user_id, metadata, created_at, ip_address, request_url
`

type CreateEventParams struct {
	Level      string        `json:"level"`
	Category   string        `json:"category"`
	Message    string        `json:"message"`
	UserID     sql.NullInt64 `json:"user_id"`
	Metadata   string        `json:"metadata"`
	IpAddress  string        `json:"ip_address"`
	RequestUrl string        `json:"request_url"`
	CreatedAt  time.Time     `json:"created_at"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRowContext(ctx, createEvent,
		arg.Level,
		arg.Category,
		arg.Message,
		arg.UserID,
		arg.Metadata,
		arg.IpAddress,
		arg.RequestUrl,
		arg.CreatedAt,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Level,
		&i.Category,
		&i.Message,
		&i.UserID,
		&i.Metadata,
		&i.CreatedAt,
		&i.IpAddress,
		&i.RequestUrl,
	)
	return i, err
}

const deleteOldEvents = `-- name: DeleteOldEvents :exec
DELETE FROM events WHERE created_at < ?
`

func (q *Queries) DeleteOldEvents(ctx context.Context, createdAt time.Time) error {
	_, err := q.db.ExecContext(ctx, deleteOldEvents, createdAt)
	return err
}

const getEvent = `-- name: GetEvent :one
SELECT id, level, category, message, user_id, metadata, created_at, ip_address, request_url FROM events WHERE id = ?
`

func (q *Queries) GetEvent(ctx context.Context, id int64) (Event, error) {
	row := q.db.QueryRowContext(ctx, getEvent, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Level,
		&i.Category,
		&i.Message,
		&i.UserID,
		&i.Metadata,
		&i.CreatedAt,
		&i.IpAddress,
		&i.RequestUrl,
	)
	return i, err
}

const listEvents = `-- name: ListEvents :many
SELECT id, level, category, message, user_id, metadata, created_at, ip_address, request_url FROM events
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListEventsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListEvents(ctx context.Context, arg ListEventsParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, listEvents, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Category,
			&i.Message,
			&i.UserID,
			&i.Metadata,
			&i.CreatedAt,
			&i.IpAddress,
			&i.RequestUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsByCategory = `-- name: ListEventsByCategory :many
SELECT id, level, category, message, user_id, metadata, created_at, ip_address, request_url FROM events
WHERE category = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListEventsByCategoryParams struct {
	Category string `json:"category"`
	Limit    int64  `json:"limit"`
	Offset   int64  `json:"offset"`
}

func (q *Queries) ListEventsByCategory(ctx context.Context, arg ListEventsByCategoryParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, listEventsByCategory, arg.Category, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Category,
			&i.Message,
			&i.UserID,
			&i.Metadata,
			&i.CreatedAt,
			&i.IpAddress,
			&i.RequestUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsByLevel = `-- name: ListEventsByLevel :many
SELECT id, level, category, message, user_id, metadata, created_at, ip_address, request_url FROM events
WHERE level = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListEventsByLevelParams struct {
	Level  string `json:"level"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

func (q *Queries) ListEventsByLevel(ctx context.Context, arg ListEventsByLevelParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, listEventsByLevel, arg.Level, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Category,
			&i.Message,
			&i.UserID,
			&i.Metadata,
			&i.CreatedAt,
			&i.IpAddress,
			&i.RequestUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsByLevelAndCategory = `-- name: ListEventsByLevelAndCategory :many
SELECT id, level, category, message, user_id, metadata, created_at, ip_address, request_url FROM events
WHERE level = ? AND category = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListEventsByLevelAndCategoryParams struct {
	Level    string `json:"level"`
	Category string `json:"category"`
	Limit    int64  `json:"limit"`
	Offset   int64  `json:"offset"`
}

func (q *Queries) ListEventsByLevelAndCategory(ctx context.Context, arg ListEventsByLevelAndCategoryParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, listEventsByLevelAndCategory,
		arg.Level,
		arg.Category,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Category,
			&i.Message,
			&i.UserID,
			&i.Metadata,
			&i.CreatedAt,
			&i.IpAddress,
			&i.RequestUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsWithUser = `-- name: ListEventsWithUser :many
SELECT e.id, e.level, e.category, e.message, e.user_id, e.metadata, e.ip_address, e.request_url, e.created_at,
       u.name as user_name, u.email as user_email
FROM events e
LEFT JOIN users u ON e.user_id = u.id
ORDER BY e.created_at DESC
LIMIT ? OFFSET ?
`

type ListEventsWithUserParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type ListEventsWithUserRow struct {
	ID         int64          `json:"id"`
	Level      string         `json:"level"`
	Category   string         `json:"category"`
	Message    string         `json:"message"`
	UserID     sql.NullInt64  `json:"user_id"`
	Metadata   string         `json:"metadata"`
	IpAddress  string         `json:"ip_address"`
	RequestUrl string         `json:"request_url"`
	CreatedAt  time.Time      `json:"created_at"`
	UserName   sql.NullString `json:"user_name"`
	UserEmail  sql.NullString `json:"user_email"`
}

func (q *Queries) ListEventsWithUser(ctx context.Context, arg ListEventsWithUserParams) ([]ListEventsWithUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listEventsWithUser, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventsWithUserRow{}
	for rows.Next() {
		var i ListEventsWithUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Category,
			&i.Message,
			&i.UserID,
			&i.Metadata,
			&i.IpAddress,
			&i.RequestUrl,
			&i.CreatedAt,
			&i.UserName,
			&i.UserEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsWithUserByCategory = `-- name: ListEventsWithUserByCategory :many
SELECT e.id, e.level, e.category, e.message, e.user_id, e.metadata, e.ip_address, e.request_url, e.created_at,
       u.name as user_name, u.email as user_email
FROM events e
LEFT JOIN users u ON e.user_id = u.id
WHERE e.category = ?
ORDER BY e.created_at DESC
LIMIT ? OFFSET ?
`

type ListEventsWithUserByCategoryParams struct {
	Category string `json:"category"`
	Limit    int64  `json:"limit"`
	Offset   int64  `json:"offset"`
}

type ListEventsWithUserByCategoryRow struct {
	ID         int64          `json:"id"`
	Level      string         `json:"level"`
	Category   string         `json:"category"`
	Message    string         `json:"message"`
	UserID     sql.NullInt64  `json:"user_id"`
	Metadata   string         `json:"metadata"`
	IpAddress  string         `json:"ip_address"`
	RequestUrl string         `json:"request_url"`
	CreatedAt  time.Time      `json:"created_at"`
	UserName   sql.NullString `json:"user_name"`
	UserEmail  sql.NullString `json:"user_email"`
}

func (q *Queries) ListEventsWithUserByCategory(ctx context.Context, arg ListEventsWithUserByCategoryParams) ([]ListEventsWithUserByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, listEventsWithUserByCategory, arg.Category, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventsWithUserByCategoryRow{}
	for rows.Next() {
		var i ListEventsWithUserByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Category,
			&i.Message,
			&i.UserID,
			&i.Metadata,
			&i.IpAddress,
			&i.RequestUrl,
			&i.CreatedAt,
			&i.UserName,
			&i.UserEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsWithUserByLevel = `-- name: ListEventsWithUserByLevel :many
SELECT e.id, e.level, e.category, e.message, e.user_id, e.metadata, e.ip_address, e.request_url, e.created_at,
       u.name as user_name, u.email as user_email
FROM events e
LEFT JOIN users u ON e.user_id = u.id
WHERE e.level = ?
ORDER BY e.created_at DESC
LIMIT ? OFFSET ?
`

type ListEventsWithUserByLevelParams struct {
	Level  string `json:"level"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

type ListEventsWithUserByLevelRow struct {
	ID         int64          `json:"id"`
	Level      string         `json:"level"`
	Category   string         `json:"category"`
	Message    string         `json:"message"`
	UserID     sql.NullInt64  `json:"user_id"`
	Metadata   string         `json:"metadata"`
	IpAddress  string         `json:"ip_address"`
	RequestUrl string         `json:"request_url"`
	CreatedAt  time.Time      `json:"created_at"`
	UserName   sql.NullString `json:"user_name"`
	UserEmail  sql.NullString `json:"user_email"`
}

func (q *Queries) ListEventsWithUserByLevel(ctx context.Context, arg ListEventsWithUserByLevelParams) ([]ListEventsWithUserByLevelRow, error) {
	rows, err := q.db.QueryContext(ctx, listEventsWithUserByLevel, arg.Level, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventsWithUserByLevelRow{}
	for rows.Next() {
		var i ListEventsWithUserByLevelRow
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Category,
			&i.Message,
			&i.UserID,
			&i.Metadata,
			&i.IpAddress,
			&i.RequestUrl,
			&i.CreatedAt,
			&i.UserName,
			&i.UserEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsWithUserByLevelAndCategory = `-- name: ListEventsWithUserByLevelAndCategory :many
SELECT e.id, e.level, e.category, e.message, e.user_id, e.metadata, e.ip_address, e.request_url, e.created_at,
       u.name as user_name, u.email as user_email
FROM events e
LEFT JOIN users u ON e.user_id = u.id
WHERE e.level = ? AND e.category = ?
ORDER BY e.created_at DESC
LIMIT ? OFFSET ?
`

type ListEventsWithUserByLevelAndCategoryParams struct {
	Level    string `json:"level"`
	Category string `json:"category"`
	Limit    int64  `json:"limit"`
	Offset   int64  `json:"offset"`
}

type ListEventsWithUserByLevelAndCategoryRow struct {
	ID         int64          `json:"id"`
	Level      string         `json:"level"`
	Category   string         `json:"category"`
	Message    string         `json:"message"`
	UserID     sql.NullInt64  `json:"user_id"`
	Metadata   string         `json:"metadata"`
	IpAddress  string         `json:"ip_address"`
	RequestUrl string         `json:"request_url"`
	CreatedAt  time.Time      `json:"created_at"`
	UserName   sql.NullString `json:"user_name"`
	UserEmail  sql.NullString `json:"user_email"`
}

func (q *Queries) ListEventsWithUserByLevelAndCategory(ctx context.Context, arg ListEventsWithUserByLevelAndCategoryParams) ([]ListEventsWithUserByLevelAndCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, listEventsWithUserByLevelAndCategory,
		arg.Level,
		arg.Category,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventsWithUserByLevelAndCategoryRow{}
	for rows.Next() {
		var i ListEventsWithUserByLevelAndCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Category,
			&i.Message,
			&i.UserID,
			&i.Metadata,
			&i.IpAddress,
			&i.RequestUrl,
			&i.CreatedAt,
			&i.UserName,
			&i.UserEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
