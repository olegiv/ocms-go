// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: translations.sql

package store

import (
	"context"
	"database/sql"
	"time"
)

const countPagesByLanguage = `-- name: CountPagesByLanguage :one
SELECT COUNT(*) FROM pages WHERE language_id = ?
`

// Count pages for a specific language
func (q *Queries) CountPagesByLanguage(ctx context.Context, languageID sql.NullInt64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPagesByLanguage, languageID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublishedPagesByLanguage = `-- name: CountPublishedPagesByLanguage :one
SELECT COUNT(*) FROM pages WHERE language_id = ? AND status = 'published'
`

// Count published pages for a specific language
func (q *Queries) CountPublishedPagesByLanguage(ctx context.Context, languageID sql.NullInt64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPublishedPagesByLanguage, languageID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTranslationsForEntity = `-- name: CountTranslationsForEntity :one
SELECT COUNT(*) FROM translations WHERE entity_type = ? AND entity_id = ?
`

type CountTranslationsForEntityParams struct {
	EntityType string `json:"entity_type"`
	EntityID   int64  `json:"entity_id"`
}

// Count translations for an entity
func (q *Queries) CountTranslationsForEntity(ctx context.Context, arg CountTranslationsForEntityParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTranslationsForEntity, arg.EntityType, arg.EntityID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTranslation = `-- name: CreateTranslation :one
INSERT INTO translations (entity_type, entity_id, language_id, translation_id, created_at)
VALUES (?, ?, ?, ?, ?)
RETURNING id, entity_type, entity_id, language_id, translation_id, created_at
`

type CreateTranslationParams struct {
	EntityType    string    `json:"entity_type"`
	EntityID      int64     `json:"entity_id"`
	LanguageID    int64     `json:"language_id"`
	TranslationID int64     `json:"translation_id"`
	CreatedAt     time.Time `json:"created_at"`
}

func (q *Queries) CreateTranslation(ctx context.Context, arg CreateTranslationParams) (Translation, error) {
	row := q.db.QueryRowContext(ctx, createTranslation,
		arg.EntityType,
		arg.EntityID,
		arg.LanguageID,
		arg.TranslationID,
		arg.CreatedAt,
	)
	var i Translation
	err := row.Scan(
		&i.ID,
		&i.EntityType,
		&i.EntityID,
		&i.LanguageID,
		&i.TranslationID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteTranslation = `-- name: DeleteTranslation :exec
DELETE FROM translations WHERE id = ?
`

func (q *Queries) DeleteTranslation(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteTranslation, id)
	return err
}

const deleteTranslationsForEntity = `-- name: DeleteTranslationsForEntity :exec
DELETE FROM translations WHERE entity_type = ? AND entity_id = ?
`

type DeleteTranslationsForEntityParams struct {
	EntityType string `json:"entity_type"`
	EntityID   int64  `json:"entity_id"`
}

func (q *Queries) DeleteTranslationsForEntity(ctx context.Context, arg DeleteTranslationsForEntityParams) error {
	_, err := q.db.ExecContext(ctx, deleteTranslationsForEntity, arg.EntityType, arg.EntityID)
	return err
}

const deleteTranslationsForEntityAndLanguage = `-- name: DeleteTranslationsForEntityAndLanguage :exec
DELETE FROM translations WHERE entity_type = ? AND entity_id = ? AND language_id = ?
`

type DeleteTranslationsForEntityAndLanguageParams struct {
	EntityType string `json:"entity_type"`
	EntityID   int64  `json:"entity_id"`
	LanguageID int64  `json:"language_id"`
}

func (q *Queries) DeleteTranslationsForEntityAndLanguage(ctx context.Context, arg DeleteTranslationsForEntityAndLanguageParams) error {
	_, err := q.db.ExecContext(ctx, deleteTranslationsForEntityAndLanguage, arg.EntityType, arg.EntityID, arg.LanguageID)
	return err
}

const getAllTranslationsOfEntity = `-- name: GetAllTranslationsOfEntity :many
SELECT t.id, t.entity_type, t.entity_id, t.language_id, t.translation_id, t.created_at, l.code as language_code, l.name as language_name, l.native_name as language_native_name
FROM translations t
INNER JOIN languages l ON l.id = t.language_id
WHERE t.entity_type = ? AND (t.entity_id = ? OR t.translation_id = ?)
ORDER BY l.position ASC
`

type GetAllTranslationsOfEntityParams struct {
	EntityType    string `json:"entity_type"`
	EntityID      int64  `json:"entity_id"`
	TranslationID int64  `json:"translation_id"`
}

type GetAllTranslationsOfEntityRow struct {
	ID                 int64     `json:"id"`
	EntityType         string    `json:"entity_type"`
	EntityID           int64     `json:"entity_id"`
	LanguageID         int64     `json:"language_id"`
	TranslationID      int64     `json:"translation_id"`
	CreatedAt          time.Time `json:"created_at"`
	LanguageCode       string    `json:"language_code"`
	LanguageName       string    `json:"language_name"`
	LanguageNativeName string    `json:"language_native_name"`
}

func (q *Queries) GetAllTranslationsOfEntity(ctx context.Context, arg GetAllTranslationsOfEntityParams) ([]GetAllTranslationsOfEntityRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllTranslationsOfEntity, arg.EntityType, arg.EntityID, arg.TranslationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllTranslationsOfEntityRow{}
	for rows.Next() {
		var i GetAllTranslationsOfEntityRow
		if err := rows.Scan(
			&i.ID,
			&i.EntityType,
			&i.EntityID,
			&i.LanguageID,
			&i.TranslationID,
			&i.CreatedAt,
			&i.LanguageCode,
			&i.LanguageName,
			&i.LanguageNativeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPageByLanguageFromTranslation = `-- name: GetPageByLanguageFromTranslation :one

SELECT p.id, p.title, p.slug, p.body, p.status, p.author_id, p.created_at, p.updated_at, p.published_at, p.featured_image_id, p.meta_title, p.meta_description, p.meta_keywords, p.og_image_id, p.no_index, p.no_follow, p.canonical_url, p.scheduled_at, p.language_id FROM pages p
INNER JOIN translations t ON t.translation_id = p.id
WHERE t.entity_type = 'page' AND t.entity_id = ? AND t.language_id = ?
`

type GetPageByLanguageFromTranslationParams struct {
	EntityID   int64 `json:"entity_id"`
	LanguageID int64 `json:"language_id"`
}

// Page-specific translation queries
func (q *Queries) GetPageByLanguageFromTranslation(ctx context.Context, arg GetPageByLanguageFromTranslationParams) (Page, error) {
	row := q.db.QueryRowContext(ctx, getPageByLanguageFromTranslation, arg.EntityID, arg.LanguageID)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Body,
		&i.Status,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.FeaturedImageID,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.OgImageID,
		&i.NoIndex,
		&i.NoFollow,
		&i.CanonicalUrl,
		&i.ScheduledAt,
		&i.LanguageID,
	)
	return i, err
}

const getPageTranslationBySlug = `-- name: GetPageTranslationBySlug :one
SELECT p.id, p.title, p.slug, p.body, p.status, p.author_id, p.created_at, p.updated_at, p.published_at, p.featured_image_id, p.meta_title, p.meta_description, p.meta_keywords, p.og_image_id, p.no_index, p.no_follow, p.canonical_url, p.scheduled_at, p.language_id FROM pages p
INNER JOIN translations t ON t.translation_id = p.id
INNER JOIN pages source ON source.id = t.entity_id
WHERE t.entity_type = 'page'
  AND source.slug = ?
  AND t.language_id = ?
  AND p.status = 'published'
`

type GetPageTranslationBySlugParams struct {
	Slug       string `json:"slug"`
	LanguageID int64  `json:"language_id"`
}

// Get the translation of a page in a specific language (by slug for frontend)
func (q *Queries) GetPageTranslationBySlug(ctx context.Context, arg GetPageTranslationBySlugParams) (Page, error) {
	row := q.db.QueryRowContext(ctx, getPageTranslationBySlug, arg.Slug, arg.LanguageID)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Body,
		&i.Status,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.FeaturedImageID,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.OgImageID,
		&i.NoIndex,
		&i.NoFollow,
		&i.CanonicalUrl,
		&i.ScheduledAt,
		&i.LanguageID,
	)
	return i, err
}

const getPageTranslationLinks = `-- name: GetPageTranslationLinks :many
SELECT
    l.id as language_id,
    l.code as language_code,
    l.name as language_name,
    l.native_name as native_name,
    COALESCE(t.translation_id, 0) as entity_id
FROM languages l
LEFT JOIN translations t ON t.language_id = l.id
    AND t.entity_type = 'page'
    AND t.entity_id = ?
WHERE l.is_active = 1
ORDER BY l.position ASC
`

type GetPageTranslationLinksRow struct {
	LanguageID   int64  `json:"language_id"`
	LanguageCode string `json:"language_code"`
	LanguageName string `json:"language_name"`
	NativeName   string `json:"native_name"`
	EntityID     int64  `json:"entity_id"`
}

// Get all translation links for a page (for language switcher)
func (q *Queries) GetPageTranslationLinks(ctx context.Context, entityID int64) ([]GetPageTranslationLinksRow, error) {
	rows, err := q.db.QueryContext(ctx, getPageTranslationLinks, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPageTranslationLinksRow{}
	for rows.Next() {
		var i GetPageTranslationLinksRow
		if err := rows.Scan(
			&i.LanguageID,
			&i.LanguageCode,
			&i.LanguageName,
			&i.NativeName,
			&i.EntityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPageWithLanguage = `-- name: GetPageWithLanguage :one
SELECT
    p.id, p.title, p.slug, p.body, p.status, p.author_id, p.created_at, p.updated_at, p.published_at, p.featured_image_id, p.meta_title, p.meta_description, p.meta_keywords, p.og_image_id, p.no_index, p.no_follow, p.canonical_url, p.scheduled_at, p.language_id,
    l.code as language_code,
    l.name as language_name,
    l.native_name as language_native_name,
    l.direction as language_direction
FROM pages p
LEFT JOIN languages l ON l.id = p.language_id
WHERE p.id = ?
`

type GetPageWithLanguageRow struct {
	ID                 int64          `json:"id"`
	Title              string         `json:"title"`
	Slug               string         `json:"slug"`
	Body               string         `json:"body"`
	Status             string         `json:"status"`
	AuthorID           int64          `json:"author_id"`
	CreatedAt          time.Time      `json:"created_at"`
	UpdatedAt          time.Time      `json:"updated_at"`
	PublishedAt        sql.NullTime   `json:"published_at"`
	FeaturedImageID    sql.NullInt64  `json:"featured_image_id"`
	MetaTitle          string         `json:"meta_title"`
	MetaDescription    string         `json:"meta_description"`
	MetaKeywords       string         `json:"meta_keywords"`
	OgImageID          sql.NullInt64  `json:"og_image_id"`
	NoIndex            int64          `json:"no_index"`
	NoFollow           int64          `json:"no_follow"`
	CanonicalUrl       string         `json:"canonical_url"`
	ScheduledAt        sql.NullTime   `json:"scheduled_at"`
	LanguageID         sql.NullInt64  `json:"language_id"`
	LanguageCode       sql.NullString `json:"language_code"`
	LanguageName       sql.NullString `json:"language_name"`
	LanguageNativeName sql.NullString `json:"language_native_name"`
	LanguageDirection  sql.NullString `json:"language_direction"`
}

// Get page with its language information
func (q *Queries) GetPageWithLanguage(ctx context.Context, id int64) (GetPageWithLanguageRow, error) {
	row := q.db.QueryRowContext(ctx, getPageWithLanguage, id)
	var i GetPageWithLanguageRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Body,
		&i.Status,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.FeaturedImageID,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.OgImageID,
		&i.NoIndex,
		&i.NoFollow,
		&i.CanonicalUrl,
		&i.ScheduledAt,
		&i.LanguageID,
		&i.LanguageCode,
		&i.LanguageName,
		&i.LanguageNativeName,
		&i.LanguageDirection,
	)
	return i, err
}

const getRelatedTranslations = `-- name: GetRelatedTranslations :many
SELECT
    t.id,
    t.entity_type,
    t.entity_id,
    t.language_id,
    t.translation_id,
    t.created_at,
    l.code as language_code,
    l.name as language_name,
    l.native_name as language_native_name
FROM translations t
INNER JOIN languages l ON l.id = t.language_id
WHERE t.entity_type = ?
  AND (t.entity_id = ? OR t.translation_id = ?)
ORDER BY l.position ASC
`

type GetRelatedTranslationsParams struct {
	EntityType    string `json:"entity_type"`
	EntityID      int64  `json:"entity_id"`
	TranslationID int64  `json:"translation_id"`
}

type GetRelatedTranslationsRow struct {
	ID                 int64     `json:"id"`
	EntityType         string    `json:"entity_type"`
	EntityID           int64     `json:"entity_id"`
	LanguageID         int64     `json:"language_id"`
	TranslationID      int64     `json:"translation_id"`
	CreatedAt          time.Time `json:"created_at"`
	LanguageCode       string    `json:"language_code"`
	LanguageName       string    `json:"language_name"`
	LanguageNativeName string    `json:"language_native_name"`
}

// Get all translations related to an entity (where entity is either source or target)
func (q *Queries) GetRelatedTranslations(ctx context.Context, arg GetRelatedTranslationsParams) ([]GetRelatedTranslationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRelatedTranslations, arg.EntityType, arg.EntityID, arg.TranslationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRelatedTranslationsRow{}
	for rows.Next() {
		var i GetRelatedTranslationsRow
		if err := rows.Scan(
			&i.ID,
			&i.EntityType,
			&i.EntityID,
			&i.LanguageID,
			&i.TranslationID,
			&i.CreatedAt,
			&i.LanguageCode,
			&i.LanguageName,
			&i.LanguageNativeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTranslatedEntityID = `-- name: GetTranslatedEntityID :one
SELECT translation_id FROM translations
WHERE entity_type = ? AND entity_id = ? AND language_id = ?
`

type GetTranslatedEntityIDParams struct {
	EntityType string `json:"entity_type"`
	EntityID   int64  `json:"entity_id"`
	LanguageID int64  `json:"language_id"`
}

// Get the translated entity ID for a given entity and target language
func (q *Queries) GetTranslatedEntityID(ctx context.Context, arg GetTranslatedEntityIDParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTranslatedEntityID, arg.EntityType, arg.EntityID, arg.LanguageID)
	var translation_id int64
	err := row.Scan(&translation_id)
	return translation_id, err
}

const getTranslation = `-- name: GetTranslation :one
SELECT id, entity_type, entity_id, language_id, translation_id, created_at FROM translations
WHERE entity_type = ? AND entity_id = ? AND language_id = ?
`

type GetTranslationParams struct {
	EntityType string `json:"entity_type"`
	EntityID   int64  `json:"entity_id"`
	LanguageID int64  `json:"language_id"`
}

func (q *Queries) GetTranslation(ctx context.Context, arg GetTranslationParams) (Translation, error) {
	row := q.db.QueryRowContext(ctx, getTranslation, arg.EntityType, arg.EntityID, arg.LanguageID)
	var i Translation
	err := row.Scan(
		&i.ID,
		&i.EntityType,
		&i.EntityID,
		&i.LanguageID,
		&i.TranslationID,
		&i.CreatedAt,
	)
	return i, err
}

const getTranslationByID = `-- name: GetTranslationByID :one
SELECT id, entity_type, entity_id, language_id, translation_id, created_at FROM translations WHERE id = ?
`

func (q *Queries) GetTranslationByID(ctx context.Context, id int64) (Translation, error) {
	row := q.db.QueryRowContext(ctx, getTranslationByID, id)
	var i Translation
	err := row.Scan(
		&i.ID,
		&i.EntityType,
		&i.EntityID,
		&i.LanguageID,
		&i.TranslationID,
		&i.CreatedAt,
	)
	return i, err
}

const getTranslationsForEntity = `-- name: GetTranslationsForEntity :many
SELECT t.id, t.entity_type, t.entity_id, t.language_id, t.translation_id, t.created_at, l.code as language_code, l.name as language_name, l.native_name as language_native_name
FROM translations t
INNER JOIN languages l ON l.id = t.language_id
WHERE t.entity_type = ? AND t.entity_id = ?
ORDER BY l.position ASC
`

type GetTranslationsForEntityParams struct {
	EntityType string `json:"entity_type"`
	EntityID   int64  `json:"entity_id"`
}

type GetTranslationsForEntityRow struct {
	ID                 int64     `json:"id"`
	EntityType         string    `json:"entity_type"`
	EntityID           int64     `json:"entity_id"`
	LanguageID         int64     `json:"language_id"`
	TranslationID      int64     `json:"translation_id"`
	CreatedAt          time.Time `json:"created_at"`
	LanguageCode       string    `json:"language_code"`
	LanguageName       string    `json:"language_name"`
	LanguageNativeName string    `json:"language_native_name"`
}

func (q *Queries) GetTranslationsForEntity(ctx context.Context, arg GetTranslationsForEntityParams) ([]GetTranslationsForEntityRow, error) {
	rows, err := q.db.QueryContext(ctx, getTranslationsForEntity, arg.EntityType, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTranslationsForEntityRow{}
	for rows.Next() {
		var i GetTranslationsForEntityRow
		if err := rows.Scan(
			&i.ID,
			&i.EntityType,
			&i.EntityID,
			&i.LanguageID,
			&i.TranslationID,
			&i.CreatedAt,
			&i.LanguageCode,
			&i.LanguageName,
			&i.LanguageNativeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPagesByLanguage = `-- name: ListPagesByLanguage :many
SELECT id, title, slug, body, status, author_id, created_at, updated_at, published_at, featured_image_id, meta_title, meta_description, meta_keywords, og_image_id, no_index, no_follow, canonical_url, scheduled_at, language_id FROM pages
WHERE language_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListPagesByLanguageParams struct {
	LanguageID sql.NullInt64 `json:"language_id"`
	Limit      int64         `json:"limit"`
	Offset     int64         `json:"offset"`
}

// List all pages for a specific language
func (q *Queries) ListPagesByLanguage(ctx context.Context, arg ListPagesByLanguageParams) ([]Page, error) {
	rows, err := q.db.QueryContext(ctx, listPagesByLanguage, arg.LanguageID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Page{}
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Body,
			&i.Status,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.FeaturedImageID,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImageID,
			&i.NoIndex,
			&i.NoFollow,
			&i.CanonicalUrl,
			&i.ScheduledAt,
			&i.LanguageID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedPagesByLanguage = `-- name: ListPublishedPagesByLanguage :many
SELECT id, title, slug, body, status, author_id, created_at, updated_at, published_at, featured_image_id, meta_title, meta_description, meta_keywords, og_image_id, no_index, no_follow, canonical_url, scheduled_at, language_id FROM pages
WHERE language_id = ? AND status = 'published'
ORDER BY published_at DESC
LIMIT ? OFFSET ?
`

type ListPublishedPagesByLanguageParams struct {
	LanguageID sql.NullInt64 `json:"language_id"`
	Limit      int64         `json:"limit"`
	Offset     int64         `json:"offset"`
}

// List published pages for a specific language
func (q *Queries) ListPublishedPagesByLanguage(ctx context.Context, arg ListPublishedPagesByLanguageParams) ([]Page, error) {
	rows, err := q.db.QueryContext(ctx, listPublishedPagesByLanguage, arg.LanguageID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Page{}
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Body,
			&i.Status,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.FeaturedImageID,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImageID,
			&i.NoIndex,
			&i.NoFollow,
			&i.CanonicalUrl,
			&i.ScheduledAt,
			&i.LanguageID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const translationExists = `-- name: TranslationExists :one
SELECT EXISTS(
    SELECT 1 FROM translations
    WHERE entity_type = ? AND entity_id = ? AND language_id = ?
)
`

type TranslationExistsParams struct {
	EntityType string `json:"entity_type"`
	EntityID   int64  `json:"entity_id"`
	LanguageID int64  `json:"language_id"`
}

// Check if translation exists
func (q *Queries) TranslationExists(ctx context.Context, arg TranslationExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, translationExists, arg.EntityType, arg.EntityID, arg.LanguageID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const updatePageLanguage = `-- name: UpdatePageLanguage :exec
UPDATE pages SET language_id = ?, updated_at = ? WHERE id = ?
`

type UpdatePageLanguageParams struct {
	LanguageID sql.NullInt64 `json:"language_id"`
	UpdatedAt  time.Time     `json:"updated_at"`
	ID         int64         `json:"id"`
}

// Update page language
func (q *Queries) UpdatePageLanguage(ctx context.Context, arg UpdatePageLanguageParams) error {
	_, err := q.db.ExecContext(ctx, updatePageLanguage, arg.LanguageID, arg.UpdatedAt, arg.ID)
	return err
}
