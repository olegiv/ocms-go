// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: translations.sql

package store

import (
	"context"
	"database/sql"
	"time"
)

const countPagesByLanguage = `-- name: CountPagesByLanguage :one
SELECT COUNT(*) FROM pages WHERE language_code = ?
`

// Count pages for a specific language
func (q *Queries) CountPagesByLanguage(ctx context.Context, languageCode string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPagesByLanguage, languageCode)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublishedPagesByLanguage = `-- name: CountPublishedPagesByLanguage :one
SELECT COUNT(*) FROM pages WHERE language_code = ? AND status = 'published'
`

// Count published pages for a specific language
func (q *Queries) CountPublishedPagesByLanguage(ctx context.Context, languageCode string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPublishedPagesByLanguage, languageCode)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTranslationsForEntity = `-- name: CountTranslationsForEntity :one
SELECT COUNT(*) FROM translations WHERE entity_type = ? AND entity_id = ?
`

type CountTranslationsForEntityParams struct {
	EntityType string `json:"entity_type"`
	EntityID   int64  `json:"entity_id"`
}

// Count translations for an entity
func (q *Queries) CountTranslationsForEntity(ctx context.Context, arg CountTranslationsForEntityParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTranslationsForEntity, arg.EntityType, arg.EntityID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTranslation = `-- name: CreateTranslation :one
INSERT INTO translations (entity_type, entity_id, language_id, translation_id, created_at)
VALUES (?, ?, ?, ?, ?)
RETURNING id, entity_type, entity_id, language_id, translation_id, created_at
`

type CreateTranslationParams struct {
	EntityType    string    `json:"entity_type"`
	EntityID      int64     `json:"entity_id"`
	LanguageID    int64     `json:"language_id"`
	TranslationID int64     `json:"translation_id"`
	CreatedAt     time.Time `json:"created_at"`
}

func (q *Queries) CreateTranslation(ctx context.Context, arg CreateTranslationParams) (Translation, error) {
	row := q.db.QueryRowContext(ctx, createTranslation,
		arg.EntityType,
		arg.EntityID,
		arg.LanguageID,
		arg.TranslationID,
		arg.CreatedAt,
	)
	var i Translation
	err := row.Scan(
		&i.ID,
		&i.EntityType,
		&i.EntityID,
		&i.LanguageID,
		&i.TranslationID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteTranslation = `-- name: DeleteTranslation :exec
DELETE FROM translations WHERE id = ?
`

func (q *Queries) DeleteTranslation(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteTranslation, id)
	return err
}

const deleteTranslationsForEntity = `-- name: DeleteTranslationsForEntity :exec
DELETE FROM translations WHERE entity_type = ? AND entity_id = ?
`

type DeleteTranslationsForEntityParams struct {
	EntityType string `json:"entity_type"`
	EntityID   int64  `json:"entity_id"`
}

func (q *Queries) DeleteTranslationsForEntity(ctx context.Context, arg DeleteTranslationsForEntityParams) error {
	_, err := q.db.ExecContext(ctx, deleteTranslationsForEntity, arg.EntityType, arg.EntityID)
	return err
}

const deleteTranslationsForEntityAndLanguage = `-- name: DeleteTranslationsForEntityAndLanguage :exec
DELETE FROM translations WHERE entity_type = ? AND entity_id = ? AND language_id = ?
`

type DeleteTranslationsForEntityAndLanguageParams struct {
	EntityType string `json:"entity_type"`
	EntityID   int64  `json:"entity_id"`
	LanguageID int64  `json:"language_id"`
}

func (q *Queries) DeleteTranslationsForEntityAndLanguage(ctx context.Context, arg DeleteTranslationsForEntityAndLanguageParams) error {
	_, err := q.db.ExecContext(ctx, deleteTranslationsForEntityAndLanguage, arg.EntityType, arg.EntityID, arg.LanguageID)
	return err
}

const getAllTranslationsOfEntity = `-- name: GetAllTranslationsOfEntity :many
SELECT t.id, t.entity_type, t.entity_id, t.language_id, t.translation_id, t.created_at, l.code as language_code, l.name as language_name, l.native_name as language_native_name
FROM translations t
INNER JOIN languages l ON l.id = t.language_id
WHERE t.entity_type = ? AND (t.entity_id = ? OR t.translation_id = ?)
ORDER BY l.position
`

type GetAllTranslationsOfEntityParams struct {
	EntityType    string `json:"entity_type"`
	EntityID      int64  `json:"entity_id"`
	TranslationID int64  `json:"translation_id"`
}

type GetAllTranslationsOfEntityRow struct {
	ID                 int64     `json:"id"`
	EntityType         string    `json:"entity_type"`
	EntityID           int64     `json:"entity_id"`
	LanguageID         int64     `json:"language_id"`
	TranslationID      int64     `json:"translation_id"`
	CreatedAt          time.Time `json:"created_at"`
	LanguageCode       string    `json:"language_code"`
	LanguageName       string    `json:"language_name"`
	LanguageNativeName string    `json:"language_native_name"`
}

func (q *Queries) GetAllTranslationsOfEntity(ctx context.Context, arg GetAllTranslationsOfEntityParams) ([]GetAllTranslationsOfEntityRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllTranslationsOfEntity, arg.EntityType, arg.EntityID, arg.TranslationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllTranslationsOfEntityRow{}
	for rows.Next() {
		var i GetAllTranslationsOfEntityRow
		if err := rows.Scan(
			&i.ID,
			&i.EntityType,
			&i.EntityID,
			&i.LanguageID,
			&i.TranslationID,
			&i.CreatedAt,
			&i.LanguageCode,
			&i.LanguageName,
			&i.LanguageNativeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPageAvailableTranslations = `-- name: GetPageAvailableTranslations :many
SELECT
    l.id as language_id,
    l.code as language_code,
    l.name as language_name,
    l.native_name as language_native_name,
    l.direction as language_direction,
    l.is_default as is_default,
    COALESCE(p.id, 0) as page_id,
    COALESCE(p.slug, '') as page_slug,
    COALESCE(p.title, '') as page_title
FROM languages l
LEFT JOIN (
    -- Get pages that are translations of the source page
    SELECT p.id, p.slug, p.title, p.language_code
    FROM pages p
    INNER JOIN translations t ON t.translation_id = p.id
    WHERE t.entity_type = 'page' AND t.entity_id = ? AND p.status = 'published'
    UNION
    -- Get the source page itself
    SELECT p.id, p.slug, p.title, p.language_code
    FROM pages p
    WHERE p.id = ? AND p.status = 'published'
    UNION
    -- Get pages where current page is a translation (sibling translations)
    SELECT p2.id, p2.slug, p2.title, p2.language_code
    FROM translations t
    INNER JOIN pages p2 ON (p2.id = t.entity_id OR p2.id = t.translation_id)
    WHERE t.entity_type = 'page'
    AND (t.entity_id = ? OR t.translation_id = ?)
    AND p2.status = 'published'
) p ON p.language_code = l.code
WHERE l.is_active = 1
ORDER BY l.position
`

type GetPageAvailableTranslationsParams struct {
	EntityID      int64 `json:"entity_id"`
	ID            int64 `json:"id"`
	EntityID_2    int64 `json:"entity_id_2"`
	TranslationID int64 `json:"translation_id"`
}

type GetPageAvailableTranslationsRow struct {
	LanguageID         int64  `json:"language_id"`
	LanguageCode       string `json:"language_code"`
	LanguageName       string `json:"language_name"`
	LanguageNativeName string `json:"language_native_name"`
	LanguageDirection  string `json:"language_direction"`
	IsDefault          bool   `json:"is_default"`
	PageID             int64  `json:"page_id"`
	PageSlug           string `json:"page_slug"`
	PageTitle          string `json:"page_title"`
}

// Get all available translations for a page (for language switcher)
// Returns the page itself plus all its translations with language info and page slugs
func (q *Queries) GetPageAvailableTranslations(ctx context.Context, arg GetPageAvailableTranslationsParams) ([]GetPageAvailableTranslationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPageAvailableTranslations,
		arg.EntityID,
		arg.ID,
		arg.EntityID_2,
		arg.TranslationID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPageAvailableTranslationsRow{}
	for rows.Next() {
		var i GetPageAvailableTranslationsRow
		if err := rows.Scan(
			&i.LanguageID,
			&i.LanguageCode,
			&i.LanguageName,
			&i.LanguageNativeName,
			&i.LanguageDirection,
			&i.IsDefault,
			&i.PageID,
			&i.PageSlug,
			&i.PageTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPageByLanguageFromTranslation = `-- name: GetPageByLanguageFromTranslation :one

SELECT p.id, p.title, p.slug, p.body, p.status, p.author_id, p.created_at, p.updated_at, p.published_at, p.featured_image_id, p.meta_title, p.meta_description, p.meta_keywords, p.og_image_id, p.no_index, p.no_follow, p.canonical_url, p.scheduled_at, p.language_code FROM pages p
INNER JOIN translations t ON t.translation_id = p.id
WHERE t.entity_type = 'page' AND t.entity_id = ? AND t.language_id = ?
`

type GetPageByLanguageFromTranslationParams struct {
	EntityID   int64 `json:"entity_id"`
	LanguageID int64 `json:"language_id"`
}

// Page-specific translation queries
func (q *Queries) GetPageByLanguageFromTranslation(ctx context.Context, arg GetPageByLanguageFromTranslationParams) (Page, error) {
	row := q.db.QueryRowContext(ctx, getPageByLanguageFromTranslation, arg.EntityID, arg.LanguageID)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Body,
		&i.Status,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.FeaturedImageID,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.OgImageID,
		&i.NoIndex,
		&i.NoFollow,
		&i.CanonicalUrl,
		&i.ScheduledAt,
		&i.LanguageCode,
	)
	return i, err
}

const getPageTranslationBySlug = `-- name: GetPageTranslationBySlug :one
SELECT p.id, p.title, p.slug, p.body, p.status, p.author_id, p.created_at, p.updated_at, p.published_at, p.featured_image_id, p.meta_title, p.meta_description, p.meta_keywords, p.og_image_id, p.no_index, p.no_follow, p.canonical_url, p.scheduled_at, p.language_code FROM pages p
INNER JOIN translations t ON t.translation_id = p.id
INNER JOIN pages source ON source.id = t.entity_id
WHERE t.entity_type = 'page'
  AND source.slug = ?
  AND t.language_id = ?
  AND p.status = 'published'
`

type GetPageTranslationBySlugParams struct {
	Slug       string `json:"slug"`
	LanguageID int64  `json:"language_id"`
}

// Get the translation of a page in a specific language (by slug for frontend)
func (q *Queries) GetPageTranslationBySlug(ctx context.Context, arg GetPageTranslationBySlugParams) (Page, error) {
	row := q.db.QueryRowContext(ctx, getPageTranslationBySlug, arg.Slug, arg.LanguageID)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Body,
		&i.Status,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.FeaturedImageID,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.OgImageID,
		&i.NoIndex,
		&i.NoFollow,
		&i.CanonicalUrl,
		&i.ScheduledAt,
		&i.LanguageCode,
	)
	return i, err
}

const getPageTranslationLinks = `-- name: GetPageTranslationLinks :many
SELECT
    l.id as language_id,
    l.code as language_code,
    l.name as language_name,
    l.native_name as native_name,
    COALESCE(t.translation_id, 0) as entity_id
FROM languages l
LEFT JOIN translations t ON t.language_id = l.id
    AND t.entity_type = 'page'
    AND t.entity_id = ?
WHERE l.is_active = 1
ORDER BY l.position
`

type GetPageTranslationLinksRow struct {
	LanguageID   int64  `json:"language_id"`
	LanguageCode string `json:"language_code"`
	LanguageName string `json:"language_name"`
	NativeName   string `json:"native_name"`
	EntityID     int64  `json:"entity_id"`
}

// Get all translation links for a page (for language switcher)
func (q *Queries) GetPageTranslationLinks(ctx context.Context, entityID int64) ([]GetPageTranslationLinksRow, error) {
	rows, err := q.db.QueryContext(ctx, getPageTranslationLinks, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPageTranslationLinksRow{}
	for rows.Next() {
		var i GetPageTranslationLinksRow
		if err := rows.Scan(
			&i.LanguageID,
			&i.LanguageCode,
			&i.LanguageName,
			&i.NativeName,
			&i.EntityID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPageWithLanguage = `-- name: GetPageWithLanguage :one
SELECT
    p.id, p.title, p.slug, p.body, p.status, p.author_id, p.created_at, p.updated_at, p.published_at, p.featured_image_id, p.meta_title, p.meta_description, p.meta_keywords, p.og_image_id, p.no_index, p.no_follow, p.canonical_url, p.scheduled_at, p.language_code,
    l.name as language_name,
    l.native_name as language_native_name,
    l.direction as language_direction
FROM pages p
INNER JOIN languages l ON l.code = p.language_code
WHERE p.id = ?
`

type GetPageWithLanguageRow struct {
	ID                 int64         `json:"id"`
	Title              string        `json:"title"`
	Slug               string        `json:"slug"`
	Body               string        `json:"body"`
	Status             string        `json:"status"`
	AuthorID           int64         `json:"author_id"`
	CreatedAt          time.Time     `json:"created_at"`
	UpdatedAt          time.Time     `json:"updated_at"`
	PublishedAt        sql.NullTime  `json:"published_at"`
	FeaturedImageID    sql.NullInt64 `json:"featured_image_id"`
	MetaTitle          string        `json:"meta_title"`
	MetaDescription    string        `json:"meta_description"`
	MetaKeywords       string        `json:"meta_keywords"`
	OgImageID          sql.NullInt64 `json:"og_image_id"`
	NoIndex            int64         `json:"no_index"`
	NoFollow           int64         `json:"no_follow"`
	CanonicalUrl       string        `json:"canonical_url"`
	ScheduledAt        sql.NullTime  `json:"scheduled_at"`
	LanguageCode       string        `json:"language_code"`
	LanguageName       string        `json:"language_name"`
	LanguageNativeName string        `json:"language_native_name"`
	LanguageDirection  string        `json:"language_direction"`
}

// Get page with its language information (no JOIN needed - language_code is on pages)
func (q *Queries) GetPageWithLanguage(ctx context.Context, id int64) (GetPageWithLanguageRow, error) {
	row := q.db.QueryRowContext(ctx, getPageWithLanguage, id)
	var i GetPageWithLanguageRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Body,
		&i.Status,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.FeaturedImageID,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.OgImageID,
		&i.NoIndex,
		&i.NoFollow,
		&i.CanonicalUrl,
		&i.ScheduledAt,
		&i.LanguageCode,
		&i.LanguageName,
		&i.LanguageNativeName,
		&i.LanguageDirection,
	)
	return i, err
}

const getPublishedPageWithLanguageBySlug = `-- name: GetPublishedPageWithLanguageBySlug :one
SELECT
    p.id, p.title, p.slug, p.body, p.status, p.author_id, p.created_at, p.updated_at, p.published_at, p.featured_image_id, p.meta_title, p.meta_description, p.meta_keywords, p.og_image_id, p.no_index, p.no_follow, p.canonical_url, p.scheduled_at, p.language_code,
    l.name as language_name,
    l.native_name as language_native_name,
    l.direction as language_direction,
    l.is_default as language_is_default
FROM pages p
INNER JOIN languages l ON l.code = p.language_code
WHERE p.slug = ? AND p.status = 'published'
`

type GetPublishedPageWithLanguageBySlugRow struct {
	ID                 int64         `json:"id"`
	Title              string        `json:"title"`
	Slug               string        `json:"slug"`
	Body               string        `json:"body"`
	Status             string        `json:"status"`
	AuthorID           int64         `json:"author_id"`
	CreatedAt          time.Time     `json:"created_at"`
	UpdatedAt          time.Time     `json:"updated_at"`
	PublishedAt        sql.NullTime  `json:"published_at"`
	FeaturedImageID    sql.NullInt64 `json:"featured_image_id"`
	MetaTitle          string        `json:"meta_title"`
	MetaDescription    string        `json:"meta_description"`
	MetaKeywords       string        `json:"meta_keywords"`
	OgImageID          sql.NullInt64 `json:"og_image_id"`
	NoIndex            int64         `json:"no_index"`
	NoFollow           int64         `json:"no_follow"`
	CanonicalUrl       string        `json:"canonical_url"`
	ScheduledAt        sql.NullTime  `json:"scheduled_at"`
	LanguageCode       string        `json:"language_code"`
	LanguageName       string        `json:"language_name"`
	LanguageNativeName string        `json:"language_native_name"`
	LanguageDirection  string        `json:"language_direction"`
	LanguageIsDefault  bool          `json:"language_is_default"`
}

// Get page with language info by slug (no JOIN needed - language_code is on pages)
func (q *Queries) GetPublishedPageWithLanguageBySlug(ctx context.Context, slug string) (GetPublishedPageWithLanguageBySlugRow, error) {
	row := q.db.QueryRowContext(ctx, getPublishedPageWithLanguageBySlug, slug)
	var i GetPublishedPageWithLanguageBySlugRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Body,
		&i.Status,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.FeaturedImageID,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.OgImageID,
		&i.NoIndex,
		&i.NoFollow,
		&i.CanonicalUrl,
		&i.ScheduledAt,
		&i.LanguageCode,
		&i.LanguageName,
		&i.LanguageNativeName,
		&i.LanguageDirection,
		&i.LanguageIsDefault,
	)
	return i, err
}

const getRelatedTranslations = `-- name: GetRelatedTranslations :many
SELECT
    t.id,
    t.entity_type,
    t.entity_id,
    t.language_id,
    t.translation_id,
    t.created_at,
    l.code as language_code,
    l.name as language_name,
    l.native_name as language_native_name
FROM translations t
INNER JOIN languages l ON l.id = t.language_id
WHERE t.entity_type = ?
  AND (t.entity_id = ? OR t.translation_id = ?)
ORDER BY l.position
`

type GetRelatedTranslationsParams struct {
	EntityType    string `json:"entity_type"`
	EntityID      int64  `json:"entity_id"`
	TranslationID int64  `json:"translation_id"`
}

type GetRelatedTranslationsRow struct {
	ID                 int64     `json:"id"`
	EntityType         string    `json:"entity_type"`
	EntityID           int64     `json:"entity_id"`
	LanguageID         int64     `json:"language_id"`
	TranslationID      int64     `json:"translation_id"`
	CreatedAt          time.Time `json:"created_at"`
	LanguageCode       string    `json:"language_code"`
	LanguageName       string    `json:"language_name"`
	LanguageNativeName string    `json:"language_native_name"`
}

// Get all translations related to an entity (where entity is either source or target)
func (q *Queries) GetRelatedTranslations(ctx context.Context, arg GetRelatedTranslationsParams) ([]GetRelatedTranslationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRelatedTranslations, arg.EntityType, arg.EntityID, arg.TranslationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRelatedTranslationsRow{}
	for rows.Next() {
		var i GetRelatedTranslationsRow
		if err := rows.Scan(
			&i.ID,
			&i.EntityType,
			&i.EntityID,
			&i.LanguageID,
			&i.TranslationID,
			&i.CreatedAt,
			&i.LanguageCode,
			&i.LanguageName,
			&i.LanguageNativeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTranslatedEntityID = `-- name: GetTranslatedEntityID :one
SELECT translation_id FROM translations
WHERE entity_type = ? AND entity_id = ? AND language_id = ?
`

type GetTranslatedEntityIDParams struct {
	EntityType string `json:"entity_type"`
	EntityID   int64  `json:"entity_id"`
	LanguageID int64  `json:"language_id"`
}

// Get the translated entity ID for a given entity and target language
func (q *Queries) GetTranslatedEntityID(ctx context.Context, arg GetTranslatedEntityIDParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTranslatedEntityID, arg.EntityType, arg.EntityID, arg.LanguageID)
	var translation_id int64
	err := row.Scan(&translation_id)
	return translation_id, err
}

const getTranslation = `-- name: GetTranslation :one
SELECT id, entity_type, entity_id, language_id, translation_id, created_at FROM translations
WHERE entity_type = ? AND entity_id = ? AND language_id = ?
`

type GetTranslationParams struct {
	EntityType string `json:"entity_type"`
	EntityID   int64  `json:"entity_id"`
	LanguageID int64  `json:"language_id"`
}

func (q *Queries) GetTranslation(ctx context.Context, arg GetTranslationParams) (Translation, error) {
	row := q.db.QueryRowContext(ctx, getTranslation, arg.EntityType, arg.EntityID, arg.LanguageID)
	var i Translation
	err := row.Scan(
		&i.ID,
		&i.EntityType,
		&i.EntityID,
		&i.LanguageID,
		&i.TranslationID,
		&i.CreatedAt,
	)
	return i, err
}

const getTranslationByID = `-- name: GetTranslationByID :one
SELECT id, entity_type, entity_id, language_id, translation_id, created_at FROM translations WHERE id = ?
`

func (q *Queries) GetTranslationByID(ctx context.Context, id int64) (Translation, error) {
	row := q.db.QueryRowContext(ctx, getTranslationByID, id)
	var i Translation
	err := row.Scan(
		&i.ID,
		&i.EntityType,
		&i.EntityID,
		&i.LanguageID,
		&i.TranslationID,
		&i.CreatedAt,
	)
	return i, err
}

const getTranslationCountsBatch = `-- name: GetTranslationCountsBatch :many
SELECT
    entity_id,
    COUNT(*) as translation_count
FROM translations
WHERE entity_type = ?
GROUP BY entity_id
`

type GetTranslationCountsBatchRow struct {
	EntityID         int64 `json:"entity_id"`
	TranslationCount int64 `json:"translation_count"`
}

// Batch get translation counts for multiple entities (for page lists)
// Returns translation count per entity
func (q *Queries) GetTranslationCountsBatch(ctx context.Context, entityType string) ([]GetTranslationCountsBatchRow, error) {
	rows, err := q.db.QueryContext(ctx, getTranslationCountsBatch, entityType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTranslationCountsBatchRow{}
	for rows.Next() {
		var i GetTranslationCountsBatchRow
		if err := rows.Scan(&i.EntityID, &i.TranslationCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTranslationCoverage = `-- name: GetTranslationCoverage :many
SELECT
    l.id as language_id,
    l.code as language_code,
    l.name as language_name,
    l.is_default as is_default,
    COUNT(p.id) as page_count
FROM languages l
LEFT JOIN pages p ON p.language_code = l.code
WHERE l.is_active = 1
GROUP BY l.id, l.code, l.name, l.is_default, l.position
ORDER BY l.is_default DESC, l.position
`

type GetTranslationCoverageRow struct {
	LanguageID   int64  `json:"language_id"`
	LanguageCode string `json:"language_code"`
	LanguageName string `json:"language_name"`
	IsDefault    bool   `json:"is_default"`
	PageCount    int64  `json:"page_count"`
}

// Get page count per active language for translation coverage dashboard widget
func (q *Queries) GetTranslationCoverage(ctx context.Context) ([]GetTranslationCoverageRow, error) {
	rows, err := q.db.QueryContext(ctx, getTranslationCoverage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTranslationCoverageRow{}
	for rows.Next() {
		var i GetTranslationCoverageRow
		if err := rows.Scan(
			&i.LanguageID,
			&i.LanguageCode,
			&i.LanguageName,
			&i.IsDefault,
			&i.PageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTranslationStats = `-- name: GetTranslationStats :one
SELECT
    COUNT(DISTINCT entity_id) as total_entities,
    COUNT(*) as total_translations,
    (SELECT COUNT(*) FROM translations WHERE entity_type = 'page') as page_translations,
    (SELECT COUNT(*) FROM translations WHERE entity_type = 'category') as category_translations,
    (SELECT COUNT(*) FROM translations WHERE entity_type = 'tag') as tag_translations
FROM translations
`

type GetTranslationStatsRow struct {
	TotalEntities        int64 `json:"total_entities"`
	TotalTranslations    int64 `json:"total_translations"`
	PageTranslations     int64 `json:"page_translations"`
	CategoryTranslations int64 `json:"category_translations"`
	TagTranslations      int64 `json:"tag_translations"`
}

// Get total translation statistics
func (q *Queries) GetTranslationStats(ctx context.Context) (GetTranslationStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getTranslationStats)
	var i GetTranslationStatsRow
	err := row.Scan(
		&i.TotalEntities,
		&i.TotalTranslations,
		&i.PageTranslations,
		&i.CategoryTranslations,
		&i.TagTranslations,
	)
	return i, err
}

const getTranslationsForEntity = `-- name: GetTranslationsForEntity :many
SELECT t.id, t.entity_type, t.entity_id, t.language_id, t.translation_id, t.created_at, l.code as language_code, l.name as language_name, l.native_name as language_native_name
FROM translations t
INNER JOIN languages l ON l.id = t.language_id
WHERE t.entity_type = ? AND t.entity_id = ?
ORDER BY l.position
`

type GetTranslationsForEntityParams struct {
	EntityType string `json:"entity_type"`
	EntityID   int64  `json:"entity_id"`
}

type GetTranslationsForEntityRow struct {
	ID                 int64     `json:"id"`
	EntityType         string    `json:"entity_type"`
	EntityID           int64     `json:"entity_id"`
	LanguageID         int64     `json:"language_id"`
	TranslationID      int64     `json:"translation_id"`
	CreatedAt          time.Time `json:"created_at"`
	LanguageCode       string    `json:"language_code"`
	LanguageName       string    `json:"language_name"`
	LanguageNativeName string    `json:"language_native_name"`
}

func (q *Queries) GetTranslationsForEntity(ctx context.Context, arg GetTranslationsForEntityParams) ([]GetTranslationsForEntityRow, error) {
	rows, err := q.db.QueryContext(ctx, getTranslationsForEntity, arg.EntityType, arg.EntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTranslationsForEntityRow{}
	for rows.Next() {
		var i GetTranslationsForEntityRow
		if err := rows.Scan(
			&i.ID,
			&i.EntityType,
			&i.EntityID,
			&i.LanguageID,
			&i.TranslationID,
			&i.CreatedAt,
			&i.LanguageCode,
			&i.LanguageName,
			&i.LanguageNativeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTranslationsForPagesBatch = `-- name: GetTranslationsForPagesBatch :many
SELECT
    t.entity_id,
    t.language_id,
    t.translation_id,
    l.code as language_code,
    l.name as language_name
FROM translations t
INNER JOIN languages l ON l.id = t.language_id
WHERE t.entity_type = 'page'
ORDER BY t.entity_id, l.position
`

type GetTranslationsForPagesBatchRow struct {
	EntityID      int64  `json:"entity_id"`
	LanguageID    int64  `json:"language_id"`
	TranslationID int64  `json:"translation_id"`
	LanguageCode  string `json:"language_code"`
	LanguageName  string `json:"language_name"`
}

// Batch get translations for multiple page IDs (for page list with translations indicator)
func (q *Queries) GetTranslationsForPagesBatch(ctx context.Context) ([]GetTranslationsForPagesBatchRow, error) {
	rows, err := q.db.QueryContext(ctx, getTranslationsForPagesBatch)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTranslationsForPagesBatchRow{}
	for rows.Next() {
		var i GetTranslationsForPagesBatchRow
		if err := rows.Scan(
			&i.EntityID,
			&i.LanguageID,
			&i.TranslationID,
			&i.LanguageCode,
			&i.LanguageName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPagesByLanguage = `-- name: ListPagesByLanguage :many
SELECT id, title, slug, body, status, author_id, created_at, updated_at, published_at, featured_image_id, meta_title, meta_description, meta_keywords, og_image_id, no_index, no_follow, canonical_url, scheduled_at, language_code FROM pages
WHERE language_code = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListPagesByLanguageParams struct {
	LanguageCode string `json:"language_code"`
	Limit        int64  `json:"limit"`
	Offset       int64  `json:"offset"`
}

// List all pages for a specific language
func (q *Queries) ListPagesByLanguage(ctx context.Context, arg ListPagesByLanguageParams) ([]Page, error) {
	rows, err := q.db.QueryContext(ctx, listPagesByLanguage, arg.LanguageCode, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Page{}
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Body,
			&i.Status,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.FeaturedImageID,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImageID,
			&i.NoIndex,
			&i.NoFollow,
			&i.CanonicalUrl,
			&i.ScheduledAt,
			&i.LanguageCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedPagesByLanguage = `-- name: ListPublishedPagesByLanguage :many
SELECT id, title, slug, body, status, author_id, created_at, updated_at, published_at, featured_image_id, meta_title, meta_description, meta_keywords, og_image_id, no_index, no_follow, canonical_url, scheduled_at, language_code FROM pages
WHERE language_code = ? AND status = 'published'
ORDER BY published_at DESC
LIMIT ? OFFSET ?
`

type ListPublishedPagesByLanguageParams struct {
	LanguageCode string `json:"language_code"`
	Limit        int64  `json:"limit"`
	Offset       int64  `json:"offset"`
}

// List published pages for a specific language
func (q *Queries) ListPublishedPagesByLanguage(ctx context.Context, arg ListPublishedPagesByLanguageParams) ([]Page, error) {
	rows, err := q.db.QueryContext(ctx, listPublishedPagesByLanguage, arg.LanguageCode, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Page{}
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Body,
			&i.Status,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.FeaturedImageID,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImageID,
			&i.NoIndex,
			&i.NoFollow,
			&i.CanonicalUrl,
			&i.ScheduledAt,
			&i.LanguageCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const translationExists = `-- name: TranslationExists :one
SELECT EXISTS(
    SELECT 1 FROM translations
    WHERE entity_type = ? AND entity_id = ? AND language_id = ?
)
`

type TranslationExistsParams struct {
	EntityType string `json:"entity_type"`
	EntityID   int64  `json:"entity_id"`
	LanguageID int64  `json:"language_id"`
}

// Check if translation exists
func (q *Queries) TranslationExists(ctx context.Context, arg TranslationExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, translationExists, arg.EntityType, arg.EntityID, arg.LanguageID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const updatePageLanguage = `-- name: UpdatePageLanguage :exec
UPDATE pages SET language_code = ?, updated_at = ? WHERE id = ?
`

type UpdatePageLanguageParams struct {
	LanguageCode string    `json:"language_code"`
	UpdatedAt    time.Time `json:"updated_at"`
	ID           int64     `json:"id"`
}

// Update page language
func (q *Queries) UpdatePageLanguage(ctx context.Context, arg UpdatePageLanguageParams) error {
	_, err := q.db.ExecContext(ctx, updatePageLanguage, arg.LanguageCode, arg.UpdatedAt, arg.ID)
	return err
}
