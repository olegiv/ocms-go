// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pages.sql

package store

import (
	"context"
	"database/sql"
	"time"
)

const clearPageFeaturedImage = `-- name: ClearPageFeaturedImage :exec
UPDATE pages SET featured_image_id = NULL, updated_at = ? WHERE id = ?
`

type ClearPageFeaturedImageParams struct {
	UpdatedAt time.Time `json:"updated_at"`
	ID        int64     `json:"id"`
}

func (q *Queries) ClearPageFeaturedImage(ctx context.Context, arg ClearPageFeaturedImageParams) error {
	_, err := q.db.ExecContext(ctx, clearPageFeaturedImage, arg.UpdatedAt, arg.ID)
	return err
}

const clearPageScheduledAt = `-- name: ClearPageScheduledAt :exec
UPDATE pages SET scheduled_at = NULL, updated_at = ? WHERE id = ?
`

type ClearPageScheduledAtParams struct {
	UpdatedAt time.Time `json:"updated_at"`
	ID        int64     `json:"id"`
}

func (q *Queries) ClearPageScheduledAt(ctx context.Context, arg ClearPageScheduledAtParams) error {
	_, err := q.db.ExecContext(ctx, clearPageScheduledAt, arg.UpdatedAt, arg.ID)
	return err
}

const countPageVersions = `-- name: CountPageVersions :one
SELECT COUNT(*) FROM page_versions WHERE page_id = ?
`

func (q *Queries) CountPageVersions(ctx context.Context, pageID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPageVersions, pageID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPages = `-- name: CountPages :one
SELECT COUNT(*) FROM pages
`

func (q *Queries) CountPages(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPages)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPagesByLanguageAndStatus = `-- name: CountPagesByLanguageAndStatus :one
SELECT COUNT(*) FROM pages WHERE language_id = ? AND status = ?
`

type CountPagesByLanguageAndStatusParams struct {
	LanguageID sql.NullInt64 `json:"language_id"`
	Status     string        `json:"status"`
}

func (q *Queries) CountPagesByLanguageAndStatus(ctx context.Context, arg CountPagesByLanguageAndStatusParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPagesByLanguageAndStatus, arg.LanguageID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPagesByStatus = `-- name: CountPagesByStatus :one
SELECT COUNT(*) FROM pages WHERE status = ?
`

func (q *Queries) CountPagesByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPagesByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublishedPages = `-- name: CountPublishedPages :one
SELECT COUNT(*) FROM pages WHERE status = 'published'
`

func (q *Queries) CountPublishedPages(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPublishedPages)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublishedPagesByCategory = `-- name: CountPublishedPagesByCategory :one
SELECT COUNT(DISTINCT p.id) FROM pages p
INNER JOIN page_categories pc ON pc.page_id = p.id
WHERE pc.category_id = ? AND p.status = 'published'
`

func (q *Queries) CountPublishedPagesByCategory(ctx context.Context, categoryID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPublishedPagesByCategory, categoryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublishedPagesForTag = `-- name: CountPublishedPagesForTag :one
SELECT COUNT(*) FROM pages p
INNER JOIN page_tags pt ON pt.page_id = p.id
WHERE pt.tag_id = ? AND p.status = 'published'
`

func (q *Queries) CountPublishedPagesForTag(ctx context.Context, tagID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPublishedPagesForTag, tagID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countScheduledPages = `-- name: CountScheduledPages :one
SELECT COUNT(*) FROM pages WHERE scheduled_at IS NOT NULL AND status = 'draft'
`

func (q *Queries) CountScheduledPages(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countScheduledPages)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchPages = `-- name: CountSearchPages :one
SELECT COUNT(*) FROM pages
WHERE title LIKE ? OR body LIKE ? OR slug LIKE ?
`

type CountSearchPagesParams struct {
	Title string `json:"title"`
	Body  string `json:"body"`
	Slug  string `json:"slug"`
}

func (q *Queries) CountSearchPages(ctx context.Context, arg CountSearchPagesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSearchPages, arg.Title, arg.Body, arg.Slug)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchPagesByLanguage = `-- name: CountSearchPagesByLanguage :one
SELECT COUNT(*) FROM pages
WHERE language_id = ? AND (title LIKE ? OR body LIKE ? OR slug LIKE ?)
`

type CountSearchPagesByLanguageParams struct {
	LanguageID sql.NullInt64 `json:"language_id"`
	Title      string        `json:"title"`
	Body       string        `json:"body"`
	Slug       string        `json:"slug"`
}

func (q *Queries) CountSearchPagesByLanguage(ctx context.Context, arg CountSearchPagesByLanguageParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSearchPagesByLanguage,
		arg.LanguageID,
		arg.Title,
		arg.Body,
		arg.Slug,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchPagesByStatus = `-- name: CountSearchPagesByStatus :one
SELECT COUNT(*) FROM pages
WHERE status = ? AND (title LIKE ? OR body LIKE ? OR slug LIKE ?)
`

type CountSearchPagesByStatusParams struct {
	Status string `json:"status"`
	Title  string `json:"title"`
	Body   string `json:"body"`
	Slug   string `json:"slug"`
}

func (q *Queries) CountSearchPagesByStatus(ctx context.Context, arg CountSearchPagesByStatusParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSearchPagesByStatus,
		arg.Status,
		arg.Title,
		arg.Body,
		arg.Slug,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPage = `-- name: CreatePage :one
INSERT INTO pages (title, slug, body, status, author_id, featured_image_id, meta_title, meta_description, meta_keywords, og_image_id, no_index, no_follow, canonical_url, scheduled_at, language_id, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, title, slug, body, status, author_id, created_at, updated_at, published_at, featured_image_id, meta_title, meta_description, meta_keywords, og_image_id, no_index, no_follow, canonical_url, scheduled_at, language_id
`

type CreatePageParams struct {
	Title           string        `json:"title"`
	Slug            string        `json:"slug"`
	Body            string        `json:"body"`
	Status          string        `json:"status"`
	AuthorID        int64         `json:"author_id"`
	FeaturedImageID sql.NullInt64 `json:"featured_image_id"`
	MetaTitle       string        `json:"meta_title"`
	MetaDescription string        `json:"meta_description"`
	MetaKeywords    string        `json:"meta_keywords"`
	OgImageID       sql.NullInt64 `json:"og_image_id"`
	NoIndex         int64         `json:"no_index"`
	NoFollow        int64         `json:"no_follow"`
	CanonicalUrl    string        `json:"canonical_url"`
	ScheduledAt     sql.NullTime  `json:"scheduled_at"`
	LanguageID      sql.NullInt64 `json:"language_id"`
	CreatedAt       time.Time     `json:"created_at"`
	UpdatedAt       time.Time     `json:"updated_at"`
}

func (q *Queries) CreatePage(ctx context.Context, arg CreatePageParams) (Page, error) {
	row := q.db.QueryRowContext(ctx, createPage,
		arg.Title,
		arg.Slug,
		arg.Body,
		arg.Status,
		arg.AuthorID,
		arg.FeaturedImageID,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.MetaKeywords,
		arg.OgImageID,
		arg.NoIndex,
		arg.NoFollow,
		arg.CanonicalUrl,
		arg.ScheduledAt,
		arg.LanguageID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Body,
		&i.Status,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.FeaturedImageID,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.OgImageID,
		&i.NoIndex,
		&i.NoFollow,
		&i.CanonicalUrl,
		&i.ScheduledAt,
		&i.LanguageID,
	)
	return i, err
}

const createPageVersion = `-- name: CreatePageVersion :one

INSERT INTO page_versions (page_id, title, body, changed_by, created_at)
VALUES (?, ?, ?, ?, ?)
RETURNING id, page_id, title, body, changed_by, created_at
`

type CreatePageVersionParams struct {
	PageID    int64     `json:"page_id"`
	Title     string    `json:"title"`
	Body      string    `json:"body"`
	ChangedBy int64     `json:"changed_by"`
	CreatedAt time.Time `json:"created_at"`
}

// Page Version queries
func (q *Queries) CreatePageVersion(ctx context.Context, arg CreatePageVersionParams) (PageVersion, error) {
	row := q.db.QueryRowContext(ctx, createPageVersion,
		arg.PageID,
		arg.Title,
		arg.Body,
		arg.ChangedBy,
		arg.CreatedAt,
	)
	var i PageVersion
	err := row.Scan(
		&i.ID,
		&i.PageID,
		&i.Title,
		&i.Body,
		&i.ChangedBy,
		&i.CreatedAt,
	)
	return i, err
}

const deletePage = `-- name: DeletePage :exec
DELETE FROM pages WHERE id = ?
`

func (q *Queries) DeletePage(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deletePage, id)
	return err
}

const deletePageVersions = `-- name: DeletePageVersions :exec
DELETE FROM page_versions WHERE page_id = ?
`

func (q *Queries) DeletePageVersions(ctx context.Context, pageID int64) error {
	_, err := q.db.ExecContext(ctx, deletePageVersions, pageID)
	return err
}

const getFeaturedImageForPage = `-- name: GetFeaturedImageForPage :one

SELECT m.id, m.uuid, m.filename, m.mime_type, m.size, m.width, m.height, m.alt, m.caption, m.folder_id, m.uploaded_by, m.created_at, m.updated_at FROM media m
INNER JOIN pages p ON p.featured_image_id = m.id
WHERE p.id = ?
`

// Featured image queries
func (q *Queries) GetFeaturedImageForPage(ctx context.Context, id int64) (Medium, error) {
	row := q.db.QueryRowContext(ctx, getFeaturedImageForPage, id)
	var i Medium
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Filename,
		&i.MimeType,
		&i.Size,
		&i.Width,
		&i.Height,
		&i.Alt,
		&i.Caption,
		&i.FolderID,
		&i.UploadedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLatestPageVersion = `-- name: GetLatestPageVersion :one
SELECT id, page_id, title, body, changed_by, created_at FROM page_versions WHERE page_id = ? ORDER BY created_at DESC LIMIT 1
`

func (q *Queries) GetLatestPageVersion(ctx context.Context, pageID int64) (PageVersion, error) {
	row := q.db.QueryRowContext(ctx, getLatestPageVersion, pageID)
	var i PageVersion
	err := row.Scan(
		&i.ID,
		&i.PageID,
		&i.Title,
		&i.Body,
		&i.ChangedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getOGImageForPage = `-- name: GetOGImageForPage :one

SELECT m.id, m.uuid, m.filename, m.mime_type, m.size, m.width, m.height, m.alt, m.caption, m.folder_id, m.uploaded_by, m.created_at, m.updated_at FROM media m
INNER JOIN pages p ON p.og_image_id = m.id
WHERE p.id = ?
`

// SEO OG image query
func (q *Queries) GetOGImageForPage(ctx context.Context, id int64) (Medium, error) {
	row := q.db.QueryRowContext(ctx, getOGImageForPage, id)
	var i Medium
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Filename,
		&i.MimeType,
		&i.Size,
		&i.Width,
		&i.Height,
		&i.Alt,
		&i.Caption,
		&i.FolderID,
		&i.UploadedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPageAuthor = `-- name: GetPageAuthor :one
SELECT u.id, u.name, u.email FROM users u
INNER JOIN pages p ON p.author_id = u.id
WHERE p.id = ?
`

type GetPageAuthorRow struct {
	ID    int64  `json:"id"`
	Name  string `json:"name"`
	Email string `json:"email"`
}

func (q *Queries) GetPageAuthor(ctx context.Context, id int64) (GetPageAuthorRow, error) {
	row := q.db.QueryRowContext(ctx, getPageAuthor, id)
	var i GetPageAuthorRow
	err := row.Scan(&i.ID, &i.Name, &i.Email)
	return i, err
}

const getPageByID = `-- name: GetPageByID :one
SELECT id, title, slug, body, status, author_id, created_at, updated_at, published_at, featured_image_id, meta_title, meta_description, meta_keywords, og_image_id, no_index, no_follow, canonical_url, scheduled_at, language_id FROM pages WHERE id = ?
`

func (q *Queries) GetPageByID(ctx context.Context, id int64) (Page, error) {
	row := q.db.QueryRowContext(ctx, getPageByID, id)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Body,
		&i.Status,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.FeaturedImageID,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.OgImageID,
		&i.NoIndex,
		&i.NoFollow,
		&i.CanonicalUrl,
		&i.ScheduledAt,
		&i.LanguageID,
	)
	return i, err
}

const getPageBySlug = `-- name: GetPageBySlug :one
SELECT id, title, slug, body, status, author_id, created_at, updated_at, published_at, featured_image_id, meta_title, meta_description, meta_keywords, og_image_id, no_index, no_follow, canonical_url, scheduled_at, language_id FROM pages WHERE slug = ?
`

func (q *Queries) GetPageBySlug(ctx context.Context, slug string) (Page, error) {
	row := q.db.QueryRowContext(ctx, getPageBySlug, slug)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Body,
		&i.Status,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.FeaturedImageID,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.OgImageID,
		&i.NoIndex,
		&i.NoFollow,
		&i.CanonicalUrl,
		&i.ScheduledAt,
		&i.LanguageID,
	)
	return i, err
}

const getPageVersion = `-- name: GetPageVersion :one
SELECT id, page_id, title, body, changed_by, created_at FROM page_versions WHERE id = ?
`

func (q *Queries) GetPageVersion(ctx context.Context, id int64) (PageVersion, error) {
	row := q.db.QueryRowContext(ctx, getPageVersion, id)
	var i PageVersion
	err := row.Scan(
		&i.ID,
		&i.PageID,
		&i.Title,
		&i.Body,
		&i.ChangedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getPageVersionWithUser = `-- name: GetPageVersionWithUser :one
SELECT
    pv.id,
    pv.page_id,
    pv.title,
    pv.body,
    pv.changed_by,
    pv.created_at,
    u.name as changed_by_name,
    u.email as changed_by_email
FROM page_versions pv
JOIN users u ON pv.changed_by = u.id
WHERE pv.id = ?
`

type GetPageVersionWithUserRow struct {
	ID             int64     `json:"id"`
	PageID         int64     `json:"page_id"`
	Title          string    `json:"title"`
	Body           string    `json:"body"`
	ChangedBy      int64     `json:"changed_by"`
	CreatedAt      time.Time `json:"created_at"`
	ChangedByName  string    `json:"changed_by_name"`
	ChangedByEmail string    `json:"changed_by_email"`
}

func (q *Queries) GetPageVersionWithUser(ctx context.Context, id int64) (GetPageVersionWithUserRow, error) {
	row := q.db.QueryRowContext(ctx, getPageVersionWithUser, id)
	var i GetPageVersionWithUserRow
	err := row.Scan(
		&i.ID,
		&i.PageID,
		&i.Title,
		&i.Body,
		&i.ChangedBy,
		&i.CreatedAt,
		&i.ChangedByName,
		&i.ChangedByEmail,
	)
	return i, err
}

const getPublishedPageBySlug = `-- name: GetPublishedPageBySlug :one
SELECT id, title, slug, body, status, author_id, created_at, updated_at, published_at, featured_image_id, meta_title, meta_description, meta_keywords, og_image_id, no_index, no_follow, canonical_url, scheduled_at, language_id FROM pages WHERE slug = ? AND status = 'published'
`

func (q *Queries) GetPublishedPageBySlug(ctx context.Context, slug string) (Page, error) {
	row := q.db.QueryRowContext(ctx, getPublishedPageBySlug, slug)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Body,
		&i.Status,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.FeaturedImageID,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.OgImageID,
		&i.NoIndex,
		&i.NoFollow,
		&i.CanonicalUrl,
		&i.ScheduledAt,
		&i.LanguageID,
	)
	return i, err
}

const getPublishedPageBySlugAndLanguage = `-- name: GetPublishedPageBySlugAndLanguage :one
SELECT id, title, slug, body, status, author_id, created_at, updated_at, published_at, featured_image_id, meta_title, meta_description, meta_keywords, og_image_id, no_index, no_follow, canonical_url, scheduled_at, language_id FROM pages
WHERE slug = ? AND language_id = ? AND status = 'published'
`

type GetPublishedPageBySlugAndLanguageParams struct {
	Slug       string        `json:"slug"`
	LanguageID sql.NullInt64 `json:"language_id"`
}

func (q *Queries) GetPublishedPageBySlugAndLanguage(ctx context.Context, arg GetPublishedPageBySlugAndLanguageParams) (Page, error) {
	row := q.db.QueryRowContext(ctx, getPublishedPageBySlugAndLanguage, arg.Slug, arg.LanguageID)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Body,
		&i.Status,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.FeaturedImageID,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.OgImageID,
		&i.NoIndex,
		&i.NoFollow,
		&i.CanonicalUrl,
		&i.ScheduledAt,
		&i.LanguageID,
	)
	return i, err
}

const getScheduledPagesForPublishing = `-- name: GetScheduledPagesForPublishing :many

SELECT id, title, slug, body, status, author_id, created_at, updated_at, published_at, featured_image_id, meta_title, meta_description, meta_keywords, og_image_id, no_index, no_follow, canonical_url, scheduled_at, language_id FROM pages
WHERE scheduled_at IS NOT NULL AND scheduled_at <= ? AND status = 'draft'
ORDER BY scheduled_at ASC
`

// Scheduled publishing queries
func (q *Queries) GetScheduledPagesForPublishing(ctx context.Context, scheduledAt sql.NullTime) ([]Page, error) {
	rows, err := q.db.QueryContext(ctx, getScheduledPagesForPublishing, scheduledAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Page{}
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Body,
			&i.Status,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.FeaturedImageID,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImageID,
			&i.NoIndex,
			&i.NoFollow,
			&i.CanonicalUrl,
			&i.ScheduledAt,
			&i.LanguageID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPageVersions = `-- name: ListPageVersions :many
SELECT id, page_id, title, body, changed_by, created_at FROM page_versions WHERE page_id = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListPageVersionsParams struct {
	PageID int64 `json:"page_id"`
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListPageVersions(ctx context.Context, arg ListPageVersionsParams) ([]PageVersion, error) {
	rows, err := q.db.QueryContext(ctx, listPageVersions, arg.PageID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PageVersion{}
	for rows.Next() {
		var i PageVersion
		if err := rows.Scan(
			&i.ID,
			&i.PageID,
			&i.Title,
			&i.Body,
			&i.ChangedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPageVersionsWithUser = `-- name: ListPageVersionsWithUser :many
SELECT
    pv.id,
    pv.page_id,
    pv.title,
    pv.body,
    pv.changed_by,
    pv.created_at,
    u.name as changed_by_name,
    u.email as changed_by_email
FROM page_versions pv
JOIN users u ON pv.changed_by = u.id
WHERE pv.page_id = ?
ORDER BY pv.created_at DESC
LIMIT ? OFFSET ?
`

type ListPageVersionsWithUserParams struct {
	PageID int64 `json:"page_id"`
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type ListPageVersionsWithUserRow struct {
	ID             int64     `json:"id"`
	PageID         int64     `json:"page_id"`
	Title          string    `json:"title"`
	Body           string    `json:"body"`
	ChangedBy      int64     `json:"changed_by"`
	CreatedAt      time.Time `json:"created_at"`
	ChangedByName  string    `json:"changed_by_name"`
	ChangedByEmail string    `json:"changed_by_email"`
}

func (q *Queries) ListPageVersionsWithUser(ctx context.Context, arg ListPageVersionsWithUserParams) ([]ListPageVersionsWithUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listPageVersionsWithUser, arg.PageID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPageVersionsWithUserRow{}
	for rows.Next() {
		var i ListPageVersionsWithUserRow
		if err := rows.Scan(
			&i.ID,
			&i.PageID,
			&i.Title,
			&i.Body,
			&i.ChangedBy,
			&i.CreatedAt,
			&i.ChangedByName,
			&i.ChangedByEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPages = `-- name: ListPages :many
SELECT id, title, slug, body, status, author_id, created_at, updated_at, published_at, featured_image_id, meta_title, meta_description, meta_keywords, og_image_id, no_index, no_follow, canonical_url, scheduled_at, language_id FROM pages ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListPagesParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListPages(ctx context.Context, arg ListPagesParams) ([]Page, error) {
	rows, err := q.db.QueryContext(ctx, listPages, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Page{}
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Body,
			&i.Status,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.FeaturedImageID,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImageID,
			&i.NoIndex,
			&i.NoFollow,
			&i.CanonicalUrl,
			&i.ScheduledAt,
			&i.LanguageID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPagesByLanguageAndStatus = `-- name: ListPagesByLanguageAndStatus :many
SELECT id, title, slug, body, status, author_id, created_at, updated_at, published_at, featured_image_id, meta_title, meta_description, meta_keywords, og_image_id, no_index, no_follow, canonical_url, scheduled_at, language_id FROM pages
WHERE language_id = ? AND status = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListPagesByLanguageAndStatusParams struct {
	LanguageID sql.NullInt64 `json:"language_id"`
	Status     string        `json:"status"`
	Limit      int64         `json:"limit"`
	Offset     int64         `json:"offset"`
}

func (q *Queries) ListPagesByLanguageAndStatus(ctx context.Context, arg ListPagesByLanguageAndStatusParams) ([]Page, error) {
	rows, err := q.db.QueryContext(ctx, listPagesByLanguageAndStatus,
		arg.LanguageID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Page{}
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Body,
			&i.Status,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.FeaturedImageID,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImageID,
			&i.NoIndex,
			&i.NoFollow,
			&i.CanonicalUrl,
			&i.ScheduledAt,
			&i.LanguageID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPagesByStatus = `-- name: ListPagesByStatus :many
SELECT id, title, slug, body, status, author_id, created_at, updated_at, published_at, featured_image_id, meta_title, meta_description, meta_keywords, og_image_id, no_index, no_follow, canonical_url, scheduled_at, language_id FROM pages WHERE status = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListPagesByStatusParams struct {
	Status string `json:"status"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

func (q *Queries) ListPagesByStatus(ctx context.Context, arg ListPagesByStatusParams) ([]Page, error) {
	rows, err := q.db.QueryContext(ctx, listPagesByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Page{}
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Body,
			&i.Status,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.FeaturedImageID,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImageID,
			&i.NoIndex,
			&i.NoFollow,
			&i.CanonicalUrl,
			&i.ScheduledAt,
			&i.LanguageID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPagesByStatusWithLanguage = `-- name: ListPagesByStatusWithLanguage :many
SELECT
    p.id, p.title, p.slug, p.body, p.status, p.author_id, p.created_at, p.updated_at, p.published_at, p.featured_image_id, p.meta_title, p.meta_description, p.meta_keywords, p.og_image_id, p.no_index, p.no_follow, p.canonical_url, p.scheduled_at, p.language_id,
    l.code as language_code,
    l.name as language_name,
    l.native_name as language_native_name
FROM pages p
LEFT JOIN languages l ON l.id = p.language_id
WHERE p.status = ?
ORDER BY p.created_at DESC
LIMIT ? OFFSET ?
`

type ListPagesByStatusWithLanguageParams struct {
	Status string `json:"status"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

type ListPagesByStatusWithLanguageRow struct {
	ID                 int64          `json:"id"`
	Title              string         `json:"title"`
	Slug               string         `json:"slug"`
	Body               string         `json:"body"`
	Status             string         `json:"status"`
	AuthorID           int64          `json:"author_id"`
	CreatedAt          time.Time      `json:"created_at"`
	UpdatedAt          time.Time      `json:"updated_at"`
	PublishedAt        sql.NullTime   `json:"published_at"`
	FeaturedImageID    sql.NullInt64  `json:"featured_image_id"`
	MetaTitle          string         `json:"meta_title"`
	MetaDescription    string         `json:"meta_description"`
	MetaKeywords       string         `json:"meta_keywords"`
	OgImageID          sql.NullInt64  `json:"og_image_id"`
	NoIndex            int64          `json:"no_index"`
	NoFollow           int64          `json:"no_follow"`
	CanonicalUrl       string         `json:"canonical_url"`
	ScheduledAt        sql.NullTime   `json:"scheduled_at"`
	LanguageID         sql.NullInt64  `json:"language_id"`
	LanguageCode       sql.NullString `json:"language_code"`
	LanguageName       sql.NullString `json:"language_name"`
	LanguageNativeName sql.NullString `json:"language_native_name"`
}

func (q *Queries) ListPagesByStatusWithLanguage(ctx context.Context, arg ListPagesByStatusWithLanguageParams) ([]ListPagesByStatusWithLanguageRow, error) {
	rows, err := q.db.QueryContext(ctx, listPagesByStatusWithLanguage, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPagesByStatusWithLanguageRow{}
	for rows.Next() {
		var i ListPagesByStatusWithLanguageRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Body,
			&i.Status,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.FeaturedImageID,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImageID,
			&i.NoIndex,
			&i.NoFollow,
			&i.CanonicalUrl,
			&i.ScheduledAt,
			&i.LanguageID,
			&i.LanguageCode,
			&i.LanguageName,
			&i.LanguageNativeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPagesWithLanguage = `-- name: ListPagesWithLanguage :many

SELECT
    p.id, p.title, p.slug, p.body, p.status, p.author_id, p.created_at, p.updated_at, p.published_at, p.featured_image_id, p.meta_title, p.meta_description, p.meta_keywords, p.og_image_id, p.no_index, p.no_follow, p.canonical_url, p.scheduled_at, p.language_id,
    l.code as language_code,
    l.name as language_name,
    l.native_name as language_native_name
FROM pages p
LEFT JOIN languages l ON l.id = p.language_id
ORDER BY p.created_at DESC
LIMIT ? OFFSET ?
`

type ListPagesWithLanguageParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type ListPagesWithLanguageRow struct {
	ID                 int64          `json:"id"`
	Title              string         `json:"title"`
	Slug               string         `json:"slug"`
	Body               string         `json:"body"`
	Status             string         `json:"status"`
	AuthorID           int64          `json:"author_id"`
	CreatedAt          time.Time      `json:"created_at"`
	UpdatedAt          time.Time      `json:"updated_at"`
	PublishedAt        sql.NullTime   `json:"published_at"`
	FeaturedImageID    sql.NullInt64  `json:"featured_image_id"`
	MetaTitle          string         `json:"meta_title"`
	MetaDescription    string         `json:"meta_description"`
	MetaKeywords       string         `json:"meta_keywords"`
	OgImageID          sql.NullInt64  `json:"og_image_id"`
	NoIndex            int64          `json:"no_index"`
	NoFollow           int64          `json:"no_follow"`
	CanonicalUrl       string         `json:"canonical_url"`
	ScheduledAt        sql.NullTime   `json:"scheduled_at"`
	LanguageID         sql.NullInt64  `json:"language_id"`
	LanguageCode       sql.NullString `json:"language_code"`
	LanguageName       sql.NullString `json:"language_name"`
	LanguageNativeName sql.NullString `json:"language_native_name"`
}

// Language-related page queries
func (q *Queries) ListPagesWithLanguage(ctx context.Context, arg ListPagesWithLanguageParams) ([]ListPagesWithLanguageRow, error) {
	rows, err := q.db.QueryContext(ctx, listPagesWithLanguage, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPagesWithLanguageRow{}
	for rows.Next() {
		var i ListPagesWithLanguageRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Body,
			&i.Status,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.FeaturedImageID,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImageID,
			&i.NoIndex,
			&i.NoFollow,
			&i.CanonicalUrl,
			&i.ScheduledAt,
			&i.LanguageID,
			&i.LanguageCode,
			&i.LanguageName,
			&i.LanguageNativeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedPages = `-- name: ListPublishedPages :many

SELECT id, title, slug, body, status, author_id, created_at, updated_at, published_at, featured_image_id, meta_title, meta_description, meta_keywords, og_image_id, no_index, no_follow, canonical_url, scheduled_at, language_id FROM pages WHERE status = 'published' ORDER BY published_at DESC LIMIT ? OFFSET ?
`

type ListPublishedPagesParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

// Frontend queries for public pages
func (q *Queries) ListPublishedPages(ctx context.Context, arg ListPublishedPagesParams) ([]Page, error) {
	rows, err := q.db.QueryContext(ctx, listPublishedPages, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Page{}
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Body,
			&i.Status,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.FeaturedImageID,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImageID,
			&i.NoIndex,
			&i.NoFollow,
			&i.CanonicalUrl,
			&i.ScheduledAt,
			&i.LanguageID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedPagesByCategory = `-- name: ListPublishedPagesByCategory :many
SELECT DISTINCT p.id, p.title, p.slug, p.body, p.status, p.author_id, p.created_at, p.updated_at, p.published_at, p.featured_image_id, p.meta_title, p.meta_description, p.meta_keywords, p.og_image_id, p.no_index, p.no_follow, p.canonical_url, p.scheduled_at, p.language_id FROM pages p
INNER JOIN page_categories pc ON pc.page_id = p.id
WHERE pc.category_id = ? AND p.status = 'published'
ORDER BY p.published_at DESC
LIMIT ? OFFSET ?
`

type ListPublishedPagesByCategoryParams struct {
	CategoryID int64 `json:"category_id"`
	Limit      int64 `json:"limit"`
	Offset     int64 `json:"offset"`
}

func (q *Queries) ListPublishedPagesByCategory(ctx context.Context, arg ListPublishedPagesByCategoryParams) ([]Page, error) {
	rows, err := q.db.QueryContext(ctx, listPublishedPagesByCategory, arg.CategoryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Page{}
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Body,
			&i.Status,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.FeaturedImageID,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImageID,
			&i.NoIndex,
			&i.NoFollow,
			&i.CanonicalUrl,
			&i.ScheduledAt,
			&i.LanguageID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedPagesForSitemap = `-- name: ListPublishedPagesForSitemap :many
SELECT id, slug, updated_at, no_index FROM pages
WHERE status = 'published' AND no_index = 0
ORDER BY updated_at DESC
`

type ListPublishedPagesForSitemapRow struct {
	ID        int64     `json:"id"`
	Slug      string    `json:"slug"`
	UpdatedAt time.Time `json:"updated_at"`
	NoIndex   int64     `json:"no_index"`
}

func (q *Queries) ListPublishedPagesForSitemap(ctx context.Context) ([]ListPublishedPagesForSitemapRow, error) {
	rows, err := q.db.QueryContext(ctx, listPublishedPagesForSitemap)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublishedPagesForSitemapRow{}
	for rows.Next() {
		var i ListPublishedPagesForSitemapRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.UpdatedAt,
			&i.NoIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublishedPagesForTag = `-- name: ListPublishedPagesForTag :many
SELECT p.id, p.title, p.slug, p.body, p.status, p.author_id, p.created_at, p.updated_at, p.published_at, p.featured_image_id, p.meta_title, p.meta_description, p.meta_keywords, p.og_image_id, p.no_index, p.no_follow, p.canonical_url, p.scheduled_at, p.language_id FROM pages p
INNER JOIN page_tags pt ON pt.page_id = p.id
WHERE pt.tag_id = ? AND p.status = 'published'
ORDER BY p.published_at DESC
LIMIT ? OFFSET ?
`

type ListPublishedPagesForTagParams struct {
	TagID  int64 `json:"tag_id"`
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListPublishedPagesForTag(ctx context.Context, arg ListPublishedPagesForTagParams) ([]Page, error) {
	rows, err := q.db.QueryContext(ctx, listPublishedPagesForTag, arg.TagID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Page{}
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Body,
			&i.Status,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.FeaturedImageID,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImageID,
			&i.NoIndex,
			&i.NoFollow,
			&i.CanonicalUrl,
			&i.ScheduledAt,
			&i.LanguageID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScheduledPages = `-- name: ListScheduledPages :many
SELECT id, title, slug, body, status, author_id, created_at, updated_at, published_at, featured_image_id, meta_title, meta_description, meta_keywords, og_image_id, no_index, no_follow, canonical_url, scheduled_at, language_id FROM pages WHERE scheduled_at IS NOT NULL AND status = 'draft' ORDER BY scheduled_at ASC LIMIT ? OFFSET ?
`

type ListScheduledPagesParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListScheduledPages(ctx context.Context, arg ListScheduledPagesParams) ([]Page, error) {
	rows, err := q.db.QueryContext(ctx, listScheduledPages, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Page{}
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Body,
			&i.Status,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.FeaturedImageID,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImageID,
			&i.NoIndex,
			&i.NoFollow,
			&i.CanonicalUrl,
			&i.ScheduledAt,
			&i.LanguageID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publishPage = `-- name: PublishPage :one
UPDATE pages
SET status = 'published', published_at = ?, updated_at = ?
WHERE id = ?
RETURNING id, title, slug, body, status, author_id, created_at, updated_at, published_at, featured_image_id, meta_title, meta_description, meta_keywords, og_image_id, no_index, no_follow, canonical_url, scheduled_at, language_id
`

type PublishPageParams struct {
	PublishedAt sql.NullTime `json:"published_at"`
	UpdatedAt   time.Time    `json:"updated_at"`
	ID          int64        `json:"id"`
}

func (q *Queries) PublishPage(ctx context.Context, arg PublishPageParams) (Page, error) {
	row := q.db.QueryRowContext(ctx, publishPage, arg.PublishedAt, arg.UpdatedAt, arg.ID)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Body,
		&i.Status,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.FeaturedImageID,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.OgImageID,
		&i.NoIndex,
		&i.NoFollow,
		&i.CanonicalUrl,
		&i.ScheduledAt,
		&i.LanguageID,
	)
	return i, err
}

const publishScheduledPage = `-- name: PublishScheduledPage :one
UPDATE pages
SET status = 'published', published_at = ?, scheduled_at = NULL, updated_at = ?
WHERE id = ?
RETURNING id, title, slug, body, status, author_id, created_at, updated_at, published_at, featured_image_id, meta_title, meta_description, meta_keywords, og_image_id, no_index, no_follow, canonical_url, scheduled_at, language_id
`

type PublishScheduledPageParams struct {
	PublishedAt sql.NullTime `json:"published_at"`
	UpdatedAt   time.Time    `json:"updated_at"`
	ID          int64        `json:"id"`
}

func (q *Queries) PublishScheduledPage(ctx context.Context, arg PublishScheduledPageParams) (Page, error) {
	row := q.db.QueryRowContext(ctx, publishScheduledPage, arg.PublishedAt, arg.UpdatedAt, arg.ID)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Body,
		&i.Status,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.FeaturedImageID,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.OgImageID,
		&i.NoIndex,
		&i.NoFollow,
		&i.CanonicalUrl,
		&i.ScheduledAt,
		&i.LanguageID,
	)
	return i, err
}

const searchPages = `-- name: SearchPages :many

SELECT id, title, slug, body, status, author_id, created_at, updated_at, published_at, featured_image_id, meta_title, meta_description, meta_keywords, og_image_id, no_index, no_follow, canonical_url, scheduled_at, language_id FROM pages
WHERE title LIKE ? OR body LIKE ? OR slug LIKE ?
ORDER BY updated_at DESC
LIMIT ? OFFSET ?
`

type SearchPagesParams struct {
	Title  string `json:"title"`
	Body   string `json:"body"`
	Slug   string `json:"slug"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

// Admin search queries (using LIKE for searching all pages regardless of status)
func (q *Queries) SearchPages(ctx context.Context, arg SearchPagesParams) ([]Page, error) {
	rows, err := q.db.QueryContext(ctx, searchPages,
		arg.Title,
		arg.Body,
		arg.Slug,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Page{}
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Body,
			&i.Status,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.FeaturedImageID,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImageID,
			&i.NoIndex,
			&i.NoFollow,
			&i.CanonicalUrl,
			&i.ScheduledAt,
			&i.LanguageID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPagesByLanguage = `-- name: SearchPagesByLanguage :many
SELECT id, title, slug, body, status, author_id, created_at, updated_at, published_at, featured_image_id, meta_title, meta_description, meta_keywords, og_image_id, no_index, no_follow, canonical_url, scheduled_at, language_id FROM pages
WHERE language_id = ? AND (title LIKE ? OR body LIKE ? OR slug LIKE ?)
ORDER BY updated_at DESC
LIMIT ? OFFSET ?
`

type SearchPagesByLanguageParams struct {
	LanguageID sql.NullInt64 `json:"language_id"`
	Title      string        `json:"title"`
	Body       string        `json:"body"`
	Slug       string        `json:"slug"`
	Limit      int64         `json:"limit"`
	Offset     int64         `json:"offset"`
}

func (q *Queries) SearchPagesByLanguage(ctx context.Context, arg SearchPagesByLanguageParams) ([]Page, error) {
	rows, err := q.db.QueryContext(ctx, searchPagesByLanguage,
		arg.LanguageID,
		arg.Title,
		arg.Body,
		arg.Slug,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Page{}
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Body,
			&i.Status,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.FeaturedImageID,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImageID,
			&i.NoIndex,
			&i.NoFollow,
			&i.CanonicalUrl,
			&i.ScheduledAt,
			&i.LanguageID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPagesByStatus = `-- name: SearchPagesByStatus :many
SELECT id, title, slug, body, status, author_id, created_at, updated_at, published_at, featured_image_id, meta_title, meta_description, meta_keywords, og_image_id, no_index, no_follow, canonical_url, scheduled_at, language_id FROM pages
WHERE status = ? AND (title LIKE ? OR body LIKE ? OR slug LIKE ?)
ORDER BY updated_at DESC
LIMIT ? OFFSET ?
`

type SearchPagesByStatusParams struct {
	Status string `json:"status"`
	Title  string `json:"title"`
	Body   string `json:"body"`
	Slug   string `json:"slug"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

func (q *Queries) SearchPagesByStatus(ctx context.Context, arg SearchPagesByStatusParams) ([]Page, error) {
	rows, err := q.db.QueryContext(ctx, searchPagesByStatus,
		arg.Status,
		arg.Title,
		arg.Body,
		arg.Slug,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Page{}
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Body,
			&i.Status,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.FeaturedImageID,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImageID,
			&i.NoIndex,
			&i.NoFollow,
			&i.CanonicalUrl,
			&i.ScheduledAt,
			&i.LanguageID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchPagesWithLanguage = `-- name: SearchPagesWithLanguage :many
SELECT
    p.id, p.title, p.slug, p.body, p.status, p.author_id, p.created_at, p.updated_at, p.published_at, p.featured_image_id, p.meta_title, p.meta_description, p.meta_keywords, p.og_image_id, p.no_index, p.no_follow, p.canonical_url, p.scheduled_at, p.language_id,
    l.code as language_code,
    l.name as language_name,
    l.native_name as language_native_name
FROM pages p
LEFT JOIN languages l ON l.id = p.language_id
WHERE p.title LIKE ? OR p.body LIKE ? OR p.slug LIKE ?
ORDER BY p.updated_at DESC
LIMIT ? OFFSET ?
`

type SearchPagesWithLanguageParams struct {
	Title  string `json:"title"`
	Body   string `json:"body"`
	Slug   string `json:"slug"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

type SearchPagesWithLanguageRow struct {
	ID                 int64          `json:"id"`
	Title              string         `json:"title"`
	Slug               string         `json:"slug"`
	Body               string         `json:"body"`
	Status             string         `json:"status"`
	AuthorID           int64          `json:"author_id"`
	CreatedAt          time.Time      `json:"created_at"`
	UpdatedAt          time.Time      `json:"updated_at"`
	PublishedAt        sql.NullTime   `json:"published_at"`
	FeaturedImageID    sql.NullInt64  `json:"featured_image_id"`
	MetaTitle          string         `json:"meta_title"`
	MetaDescription    string         `json:"meta_description"`
	MetaKeywords       string         `json:"meta_keywords"`
	OgImageID          sql.NullInt64  `json:"og_image_id"`
	NoIndex            int64          `json:"no_index"`
	NoFollow           int64          `json:"no_follow"`
	CanonicalUrl       string         `json:"canonical_url"`
	ScheduledAt        sql.NullTime   `json:"scheduled_at"`
	LanguageID         sql.NullInt64  `json:"language_id"`
	LanguageCode       sql.NullString `json:"language_code"`
	LanguageName       sql.NullString `json:"language_name"`
	LanguageNativeName sql.NullString `json:"language_native_name"`
}

func (q *Queries) SearchPagesWithLanguage(ctx context.Context, arg SearchPagesWithLanguageParams) ([]SearchPagesWithLanguageRow, error) {
	rows, err := q.db.QueryContext(ctx, searchPagesWithLanguage,
		arg.Title,
		arg.Body,
		arg.Slug,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchPagesWithLanguageRow{}
	for rows.Next() {
		var i SearchPagesWithLanguageRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Body,
			&i.Status,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.FeaturedImageID,
			&i.MetaTitle,
			&i.MetaDescription,
			&i.MetaKeywords,
			&i.OgImageID,
			&i.NoIndex,
			&i.NoFollow,
			&i.CanonicalUrl,
			&i.ScheduledAt,
			&i.LanguageID,
			&i.LanguageCode,
			&i.LanguageName,
			&i.LanguageNativeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const slugExists = `-- name: SlugExists :one
SELECT EXISTS(SELECT 1 FROM pages WHERE slug = ?)
`

func (q *Queries) SlugExists(ctx context.Context, slug string) (int64, error) {
	row := q.db.QueryRowContext(ctx, slugExists, slug)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const slugExistsExcluding = `-- name: SlugExistsExcluding :one
SELECT EXISTS(SELECT 1 FROM pages WHERE slug = ? AND id != ?)
`

type SlugExistsExcludingParams struct {
	Slug string `json:"slug"`
	ID   int64  `json:"id"`
}

func (q *Queries) SlugExistsExcluding(ctx context.Context, arg SlugExistsExcludingParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, slugExistsExcluding, arg.Slug, arg.ID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const unpublishPage = `-- name: UnpublishPage :one
UPDATE pages
SET status = 'draft', published_at = NULL, updated_at = ?
WHERE id = ?
RETURNING id, title, slug, body, status, author_id, created_at, updated_at, published_at, featured_image_id, meta_title, meta_description, meta_keywords, og_image_id, no_index, no_follow, canonical_url, scheduled_at, language_id
`

type UnpublishPageParams struct {
	UpdatedAt time.Time `json:"updated_at"`
	ID        int64     `json:"id"`
}

func (q *Queries) UnpublishPage(ctx context.Context, arg UnpublishPageParams) (Page, error) {
	row := q.db.QueryRowContext(ctx, unpublishPage, arg.UpdatedAt, arg.ID)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Body,
		&i.Status,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.FeaturedImageID,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.OgImageID,
		&i.NoIndex,
		&i.NoFollow,
		&i.CanonicalUrl,
		&i.ScheduledAt,
		&i.LanguageID,
	)
	return i, err
}

const updatePage = `-- name: UpdatePage :one
UPDATE pages
SET title = ?, slug = ?, body = ?, status = ?, featured_image_id = ?, meta_title = ?, meta_description = ?, meta_keywords = ?, og_image_id = ?, no_index = ?, no_follow = ?, canonical_url = ?, scheduled_at = ?, language_id = ?, updated_at = ?
WHERE id = ?
RETURNING id, title, slug, body, status, author_id, created_at, updated_at, published_at, featured_image_id, meta_title, meta_description, meta_keywords, og_image_id, no_index, no_follow, canonical_url, scheduled_at, language_id
`

type UpdatePageParams struct {
	Title           string        `json:"title"`
	Slug            string        `json:"slug"`
	Body            string        `json:"body"`
	Status          string        `json:"status"`
	FeaturedImageID sql.NullInt64 `json:"featured_image_id"`
	MetaTitle       string        `json:"meta_title"`
	MetaDescription string        `json:"meta_description"`
	MetaKeywords    string        `json:"meta_keywords"`
	OgImageID       sql.NullInt64 `json:"og_image_id"`
	NoIndex         int64         `json:"no_index"`
	NoFollow        int64         `json:"no_follow"`
	CanonicalUrl    string        `json:"canonical_url"`
	ScheduledAt     sql.NullTime  `json:"scheduled_at"`
	LanguageID      sql.NullInt64 `json:"language_id"`
	UpdatedAt       time.Time     `json:"updated_at"`
	ID              int64         `json:"id"`
}

func (q *Queries) UpdatePage(ctx context.Context, arg UpdatePageParams) (Page, error) {
	row := q.db.QueryRowContext(ctx, updatePage,
		arg.Title,
		arg.Slug,
		arg.Body,
		arg.Status,
		arg.FeaturedImageID,
		arg.MetaTitle,
		arg.MetaDescription,
		arg.MetaKeywords,
		arg.OgImageID,
		arg.NoIndex,
		arg.NoFollow,
		arg.CanonicalUrl,
		arg.ScheduledAt,
		arg.LanguageID,
		arg.UpdatedAt,
		arg.ID,
	)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Body,
		&i.Status,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.FeaturedImageID,
		&i.MetaTitle,
		&i.MetaDescription,
		&i.MetaKeywords,
		&i.OgImageID,
		&i.NoIndex,
		&i.NoFollow,
		&i.CanonicalUrl,
		&i.ScheduledAt,
		&i.LanguageID,
	)
	return i, err
}

const updatePageFeaturedImage = `-- name: UpdatePageFeaturedImage :exec
UPDATE pages SET featured_image_id = ?, updated_at = ? WHERE id = ?
`

type UpdatePageFeaturedImageParams struct {
	FeaturedImageID sql.NullInt64 `json:"featured_image_id"`
	UpdatedAt       time.Time     `json:"updated_at"`
	ID              int64         `json:"id"`
}

func (q *Queries) UpdatePageFeaturedImage(ctx context.Context, arg UpdatePageFeaturedImageParams) error {
	_, err := q.db.ExecContext(ctx, updatePageFeaturedImage, arg.FeaturedImageID, arg.UpdatedAt, arg.ID)
	return err
}
