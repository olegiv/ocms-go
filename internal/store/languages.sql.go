// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: languages.sql

package store

import (
	"context"
	"database/sql"
	"time"
)

const clearDefaultLanguage = `-- name: ClearDefaultLanguage :exec
UPDATE languages SET is_default = 0 WHERE is_default = 1
`

func (q *Queries) ClearDefaultLanguage(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearDefaultLanguage)
	return err
}

const countActiveLanguages = `-- name: CountActiveLanguages :one
SELECT COUNT(*) FROM languages WHERE is_active = 1
`

func (q *Queries) CountActiveLanguages(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActiveLanguages)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLanguages = `-- name: CountLanguages :one
SELECT COUNT(*) FROM languages
`

func (q *Queries) CountLanguages(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLanguages)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPagesByLanguageID = `-- name: CountPagesByLanguageID :one
SELECT COUNT(*) FROM pages WHERE language_id = ?
`

func (q *Queries) CountPagesByLanguageID(ctx context.Context, languageID sql.NullInt64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPagesByLanguageID, languageID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLanguage = `-- name: CreateLanguage :one
INSERT INTO languages (code, name, native_name, is_default, is_active, direction, position, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, code, name, native_name, is_default, is_active, direction, position, created_at, updated_at
`

type CreateLanguageParams struct {
	Code       string    `json:"code"`
	Name       string    `json:"name"`
	NativeName string    `json:"native_name"`
	IsDefault  bool      `json:"is_default"`
	IsActive   bool      `json:"is_active"`
	Direction  string    `json:"direction"`
	Position   int64     `json:"position"`
	CreatedAt  time.Time `json:"created_at"`
	UpdatedAt  time.Time `json:"updated_at"`
}

func (q *Queries) CreateLanguage(ctx context.Context, arg CreateLanguageParams) (Language, error) {
	row := q.db.QueryRowContext(ctx, createLanguage,
		arg.Code,
		arg.Name,
		arg.NativeName,
		arg.IsDefault,
		arg.IsActive,
		arg.Direction,
		arg.Position,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Language
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.NativeName,
		&i.IsDefault,
		&i.IsActive,
		&i.Direction,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLanguage = `-- name: DeleteLanguage :exec
DELETE FROM languages WHERE id = ?
`

func (q *Queries) DeleteLanguage(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteLanguage, id)
	return err
}

const getDefaultLanguage = `-- name: GetDefaultLanguage :one
SELECT id, code, name, native_name, is_default, is_active, direction, position, created_at, updated_at FROM languages WHERE is_default = 1
`

func (q *Queries) GetDefaultLanguage(ctx context.Context) (Language, error) {
	row := q.db.QueryRowContext(ctx, getDefaultLanguage)
	var i Language
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.NativeName,
		&i.IsDefault,
		&i.IsActive,
		&i.Direction,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLanguageByCode = `-- name: GetLanguageByCode :one
SELECT id, code, name, native_name, is_default, is_active, direction, position, created_at, updated_at FROM languages WHERE code = ?
`

func (q *Queries) GetLanguageByCode(ctx context.Context, code string) (Language, error) {
	row := q.db.QueryRowContext(ctx, getLanguageByCode, code)
	var i Language
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.NativeName,
		&i.IsDefault,
		&i.IsActive,
		&i.Direction,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLanguageByID = `-- name: GetLanguageByID :one
SELECT id, code, name, native_name, is_default, is_active, direction, position, created_at, updated_at FROM languages WHERE id = ?
`

func (q *Queries) GetLanguageByID(ctx context.Context, id int64) (Language, error) {
	row := q.db.QueryRowContext(ctx, getLanguageByID, id)
	var i Language
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.NativeName,
		&i.IsDefault,
		&i.IsActive,
		&i.Direction,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMaxLanguagePosition = `-- name: GetMaxLanguagePosition :one
SELECT COALESCE(MAX(position), 0) FROM languages
`

func (q *Queries) GetMaxLanguagePosition(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getMaxLanguagePosition)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const languageCodeExists = `-- name: LanguageCodeExists :one
SELECT EXISTS(SELECT 1 FROM languages WHERE code = ?)
`

func (q *Queries) LanguageCodeExists(ctx context.Context, code string) (int64, error) {
	row := q.db.QueryRowContext(ctx, languageCodeExists, code)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const languageCodeExistsExcluding = `-- name: LanguageCodeExistsExcluding :one
SELECT EXISTS(SELECT 1 FROM languages WHERE code = ? AND id != ?)
`

type LanguageCodeExistsExcludingParams struct {
	Code string `json:"code"`
	ID   int64  `json:"id"`
}

func (q *Queries) LanguageCodeExistsExcluding(ctx context.Context, arg LanguageCodeExistsExcludingParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, languageCodeExistsExcluding, arg.Code, arg.ID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const listActiveLanguages = `-- name: ListActiveLanguages :many
SELECT id, code, name, native_name, is_default, is_active, direction, position, created_at, updated_at FROM languages WHERE is_active = 1 ORDER BY position, name
`

func (q *Queries) ListActiveLanguages(ctx context.Context) ([]Language, error) {
	rows, err := q.db.QueryContext(ctx, listActiveLanguages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Language{}
	for rows.Next() {
		var i Language
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.NativeName,
			&i.IsDefault,
			&i.IsActive,
			&i.Direction,
			&i.Position,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLanguages = `-- name: ListLanguages :many
SELECT id, code, name, native_name, is_default, is_active, direction, position, created_at, updated_at FROM languages ORDER BY position, name
`

func (q *Queries) ListLanguages(ctx context.Context) ([]Language, error) {
	rows, err := q.db.QueryContext(ctx, listLanguages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Language{}
	for rows.Next() {
		var i Language
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.NativeName,
			&i.IsDefault,
			&i.IsActive,
			&i.Direction,
			&i.Position,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDefaultLanguage = `-- name: SetDefaultLanguage :exec
UPDATE languages SET is_default = 1, updated_at = ? WHERE id = ?
`

type SetDefaultLanguageParams struct {
	UpdatedAt time.Time `json:"updated_at"`
	ID        int64     `json:"id"`
}

func (q *Queries) SetDefaultLanguage(ctx context.Context, arg SetDefaultLanguageParams) error {
	_, err := q.db.ExecContext(ctx, setDefaultLanguage, arg.UpdatedAt, arg.ID)
	return err
}

const updateLanguage = `-- name: UpdateLanguage :one
UPDATE languages SET code = ?, name = ?, native_name = ?, is_default = ?, is_active = ?, direction = ?, position = ?, updated_at = ?
WHERE id = ?
RETURNING id, code, name, native_name, is_default, is_active, direction, position, created_at, updated_at
`

type UpdateLanguageParams struct {
	Code       string    `json:"code"`
	Name       string    `json:"name"`
	NativeName string    `json:"native_name"`
	IsDefault  bool      `json:"is_default"`
	IsActive   bool      `json:"is_active"`
	Direction  string    `json:"direction"`
	Position   int64     `json:"position"`
	UpdatedAt  time.Time `json:"updated_at"`
	ID         int64     `json:"id"`
}

func (q *Queries) UpdateLanguage(ctx context.Context, arg UpdateLanguageParams) (Language, error) {
	row := q.db.QueryRowContext(ctx, updateLanguage,
		arg.Code,
		arg.Name,
		arg.NativeName,
		arg.IsDefault,
		arg.IsActive,
		arg.Direction,
		arg.Position,
		arg.UpdatedAt,
		arg.ID,
	)
	var i Language
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.NativeName,
		&i.IsDefault,
		&i.IsActive,
		&i.Direction,
		&i.Position,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLanguagePosition = `-- name: UpdateLanguagePosition :exec
UPDATE languages SET position = ?, updated_at = ? WHERE id = ?
`

type UpdateLanguagePositionParams struct {
	Position  int64     `json:"position"`
	UpdatedAt time.Time `json:"updated_at"`
	ID        int64     `json:"id"`
}

func (q *Queries) UpdateLanguagePosition(ctx context.Context, arg UpdateLanguagePositionParams) error {
	_, err := q.db.ExecContext(ctx, updateLanguagePosition, arg.Position, arg.UpdatedAt, arg.ID)
	return err
}
