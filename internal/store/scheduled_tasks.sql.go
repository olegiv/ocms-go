// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: scheduled_tasks.sql

package store

import (
	"context"
	"database/sql"
	"time"
)

const countScheduledTaskRuns = `-- name: CountScheduledTaskRuns :one
SELECT COUNT(*) FROM scheduled_task_runs WHERE task_id = ?
`

func (q *Queries) CountScheduledTaskRuns(ctx context.Context, taskID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countScheduledTaskRuns, taskID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createScheduledTask = `-- name: CreateScheduledTask :one

INSERT INTO scheduled_tasks (name, url, schedule, is_active, timeout_seconds, created_by, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, name, url, schedule, is_active, timeout_seconds, created_by, created_at, updated_at
`

type CreateScheduledTaskParams struct {
	Name           string        `json:"name"`
	Url            string        `json:"url"`
	Schedule       string        `json:"schedule"`
	IsActive       int64         `json:"is_active"`
	TimeoutSeconds int64         `json:"timeout_seconds"`
	CreatedBy      sql.NullInt64 `json:"created_by"`
	CreatedAt      time.Time     `json:"created_at"`
	UpdatedAt      time.Time     `json:"updated_at"`
}

// Scheduled Tasks
func (q *Queries) CreateScheduledTask(ctx context.Context, arg CreateScheduledTaskParams) (ScheduledTask, error) {
	row := q.db.QueryRowContext(ctx, createScheduledTask,
		arg.Name,
		arg.Url,
		arg.Schedule,
		arg.IsActive,
		arg.TimeoutSeconds,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i ScheduledTask
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Schedule,
		&i.IsActive,
		&i.TimeoutSeconds,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createScheduledTaskRun = `-- name: CreateScheduledTaskRun :one

INSERT INTO scheduled_task_runs (task_id, status, started_at)
VALUES (?, 'pending', ?)
RETURNING id, task_id, status, status_code, response_body, error_message, duration_ms, started_at, completed_at
`

type CreateScheduledTaskRunParams struct {
	TaskID    int64     `json:"task_id"`
	StartedAt time.Time `json:"started_at"`
}

// Scheduled Task Runs
func (q *Queries) CreateScheduledTaskRun(ctx context.Context, arg CreateScheduledTaskRunParams) (ScheduledTaskRun, error) {
	row := q.db.QueryRowContext(ctx, createScheduledTaskRun, arg.TaskID, arg.StartedAt)
	var i ScheduledTaskRun
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Status,
		&i.StatusCode,
		&i.ResponseBody,
		&i.ErrorMessage,
		&i.DurationMs,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const deleteAllOldTaskRuns = `-- name: DeleteAllOldTaskRuns :exec
DELETE FROM scheduled_task_runs WHERE started_at < ?
`

func (q *Queries) DeleteAllOldTaskRuns(ctx context.Context, startedAt time.Time) error {
	_, err := q.db.ExecContext(ctx, deleteAllOldTaskRuns, startedAt)
	return err
}

const deleteOldTaskRuns = `-- name: DeleteOldTaskRuns :exec
DELETE FROM scheduled_task_runs WHERE task_id = ? AND started_at < ?
`

type DeleteOldTaskRunsParams struct {
	TaskID    int64     `json:"task_id"`
	StartedAt time.Time `json:"started_at"`
}

func (q *Queries) DeleteOldTaskRuns(ctx context.Context, arg DeleteOldTaskRunsParams) error {
	_, err := q.db.ExecContext(ctx, deleteOldTaskRuns, arg.TaskID, arg.StartedAt)
	return err
}

const deleteScheduledTask = `-- name: DeleteScheduledTask :exec
DELETE FROM scheduled_tasks WHERE id = ?
`

func (q *Queries) DeleteScheduledTask(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteScheduledTask, id)
	return err
}

const getScheduledTask = `-- name: GetScheduledTask :one
SELECT id, name, url, schedule, is_active, timeout_seconds, created_by, created_at, updated_at FROM scheduled_tasks WHERE id = ?
`

func (q *Queries) GetScheduledTask(ctx context.Context, id int64) (ScheduledTask, error) {
	row := q.db.QueryRowContext(ctx, getScheduledTask, id)
	var i ScheduledTask
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Schedule,
		&i.IsActive,
		&i.TimeoutSeconds,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActiveScheduledTasks = `-- name: ListActiveScheduledTasks :many
SELECT id, name, url, schedule, is_active, timeout_seconds, created_by, created_at, updated_at FROM scheduled_tasks WHERE is_active = 1 ORDER BY name
`

func (q *Queries) ListActiveScheduledTasks(ctx context.Context) ([]ScheduledTask, error) {
	rows, err := q.db.QueryContext(ctx, listActiveScheduledTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ScheduledTask{}
	for rows.Next() {
		var i ScheduledTask
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Url,
			&i.Schedule,
			&i.IsActive,
			&i.TimeoutSeconds,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScheduledTaskRuns = `-- name: ListScheduledTaskRuns :many
SELECT id, task_id, status, status_code, response_body, error_message, duration_ms, started_at, completed_at FROM scheduled_task_runs
WHERE task_id = ?
ORDER BY started_at DESC
LIMIT ? OFFSET ?
`

type ListScheduledTaskRunsParams struct {
	TaskID int64 `json:"task_id"`
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListScheduledTaskRuns(ctx context.Context, arg ListScheduledTaskRunsParams) ([]ScheduledTaskRun, error) {
	rows, err := q.db.QueryContext(ctx, listScheduledTaskRuns, arg.TaskID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ScheduledTaskRun{}
	for rows.Next() {
		var i ScheduledTaskRun
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.Status,
			&i.StatusCode,
			&i.ResponseBody,
			&i.ErrorMessage,
			&i.DurationMs,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScheduledTasks = `-- name: ListScheduledTasks :many
SELECT id, name, url, schedule, is_active, timeout_seconds, created_by, created_at, updated_at FROM scheduled_tasks ORDER BY name
`

func (q *Queries) ListScheduledTasks(ctx context.Context) ([]ScheduledTask, error) {
	rows, err := q.db.QueryContext(ctx, listScheduledTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ScheduledTask{}
	for rows.Next() {
		var i ScheduledTask
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Url,
			&i.Schedule,
			&i.IsActive,
			&i.TimeoutSeconds,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleScheduledTask = `-- name: ToggleScheduledTask :one
UPDATE scheduled_tasks SET is_active = ?, updated_at = ?
WHERE id = ?
RETURNING id, name, url, schedule, is_active, timeout_seconds, created_by, created_at, updated_at
`

type ToggleScheduledTaskParams struct {
	IsActive  int64     `json:"is_active"`
	UpdatedAt time.Time `json:"updated_at"`
	ID        int64     `json:"id"`
}

func (q *Queries) ToggleScheduledTask(ctx context.Context, arg ToggleScheduledTaskParams) (ScheduledTask, error) {
	row := q.db.QueryRowContext(ctx, toggleScheduledTask, arg.IsActive, arg.UpdatedAt, arg.ID)
	var i ScheduledTask
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Schedule,
		&i.IsActive,
		&i.TimeoutSeconds,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateScheduledTask = `-- name: UpdateScheduledTask :one
UPDATE scheduled_tasks SET name = ?, url = ?, schedule = ?, timeout_seconds = ?, updated_at = ?
WHERE id = ?
RETURNING id, name, url, schedule, is_active, timeout_seconds, created_by, created_at, updated_at
`

type UpdateScheduledTaskParams struct {
	Name           string    `json:"name"`
	Url            string    `json:"url"`
	Schedule       string    `json:"schedule"`
	TimeoutSeconds int64     `json:"timeout_seconds"`
	UpdatedAt      time.Time `json:"updated_at"`
	ID             int64     `json:"id"`
}

func (q *Queries) UpdateScheduledTask(ctx context.Context, arg UpdateScheduledTaskParams) (ScheduledTask, error) {
	row := q.db.QueryRowContext(ctx, updateScheduledTask,
		arg.Name,
		arg.Url,
		arg.Schedule,
		arg.TimeoutSeconds,
		arg.UpdatedAt,
		arg.ID,
	)
	var i ScheduledTask
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Schedule,
		&i.IsActive,
		&i.TimeoutSeconds,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateScheduledTaskRunFailed = `-- name: UpdateScheduledTaskRunFailed :exec
UPDATE scheduled_task_runs
SET status = 'failed', error_message = ?, duration_ms = ?, completed_at = ?
WHERE id = ?
`

type UpdateScheduledTaskRunFailedParams struct {
	ErrorMessage sql.NullString `json:"error_message"`
	DurationMs   sql.NullInt64  `json:"duration_ms"`
	CompletedAt  sql.NullTime   `json:"completed_at"`
	ID           int64          `json:"id"`
}

func (q *Queries) UpdateScheduledTaskRunFailed(ctx context.Context, arg UpdateScheduledTaskRunFailedParams) error {
	_, err := q.db.ExecContext(ctx, updateScheduledTaskRunFailed,
		arg.ErrorMessage,
		arg.DurationMs,
		arg.CompletedAt,
		arg.ID,
	)
	return err
}

const updateScheduledTaskRunSuccess = `-- name: UpdateScheduledTaskRunSuccess :exec
UPDATE scheduled_task_runs
SET status = 'success', status_code = ?, response_body = ?, duration_ms = ?, completed_at = ?
WHERE id = ?
`

type UpdateScheduledTaskRunSuccessParams struct {
	StatusCode   sql.NullInt64  `json:"status_code"`
	ResponseBody sql.NullString `json:"response_body"`
	DurationMs   sql.NullInt64  `json:"duration_ms"`
	CompletedAt  sql.NullTime   `json:"completed_at"`
	ID           int64          `json:"id"`
}

func (q *Queries) UpdateScheduledTaskRunSuccess(ctx context.Context, arg UpdateScheduledTaskRunSuccessParams) error {
	_, err := q.db.ExecContext(ctx, updateScheduledTaskRunSuccess,
		arg.StatusCode,
		arg.ResponseBody,
		arg.DurationMs,
		arg.CompletedAt,
		arg.ID,
	)
	return err
}
