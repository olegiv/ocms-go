// Copyright (c) 2025-2026 Oleg Ivanchenko
// SPDX-License-Identifier: GPL-3.0-or-later

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: webhooks.sql

package store

import (
	"context"
	"database/sql"
	"time"
)

const countActiveWebhooks = `-- name: CountActiveWebhooks :one
SELECT COUNT(*) FROM webhooks WHERE is_active = 1
`

func (q *Queries) CountActiveWebhooks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActiveWebhooks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDeliveriesByStatus = `-- name: CountDeliveriesByStatus :one
SELECT COUNT(*) FROM webhook_deliveries WHERE webhook_id = ? AND status = ?
`

type CountDeliveriesByStatusParams struct {
	WebhookID int64  `json:"webhook_id"`
	Status    string `json:"status"`
}

func (q *Queries) CountDeliveriesByStatus(ctx context.Context, arg CountDeliveriesByStatusParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDeliveriesByStatus, arg.WebhookID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countWebhookDeliveries = `-- name: CountWebhookDeliveries :one
SELECT COUNT(*) FROM webhook_deliveries WHERE webhook_id = ?
`

func (q *Queries) CountWebhookDeliveries(ctx context.Context, webhookID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countWebhookDeliveries, webhookID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countWebhooks = `-- name: CountWebhooks :one
SELECT COUNT(*) FROM webhooks
`

func (q *Queries) CountWebhooks(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countWebhooks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createWebhook = `-- name: CreateWebhook :one
INSERT INTO webhooks (name, url, secret, events, is_active, headers, created_by, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, name, url, secret, events, is_active, headers, created_by, created_at, updated_at
`

type CreateWebhookParams struct {
	Name      string    `json:"name"`
	Url       string    `json:"url"`
	Secret    string    `json:"secret"`
	Events    string    `json:"events"`
	IsActive  bool      `json:"is_active"`
	Headers   string    `json:"headers"`
	CreatedBy int64     `json:"created_by"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) CreateWebhook(ctx context.Context, arg CreateWebhookParams) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, createWebhook,
		arg.Name,
		arg.Url,
		arg.Secret,
		arg.Events,
		arg.IsActive,
		arg.Headers,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Secret,
		&i.Events,
		&i.IsActive,
		&i.Headers,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createWebhookDelivery = `-- name: CreateWebhookDelivery :one

INSERT INTO webhook_deliveries (webhook_id, event, payload, status, created_at, updated_at)
VALUES (?, ?, ?, 'pending', ?, ?)
RETURNING id, webhook_id, event, payload, response_code, response_body, attempts, next_retry_at, delivered_at, status, error_message, created_at, updated_at
`

type CreateWebhookDeliveryParams struct {
	WebhookID int64     `json:"webhook_id"`
	Event     string    `json:"event"`
	Payload   string    `json:"payload"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

// Webhook Deliveries
func (q *Queries) CreateWebhookDelivery(ctx context.Context, arg CreateWebhookDeliveryParams) (WebhookDelivery, error) {
	row := q.db.QueryRowContext(ctx, createWebhookDelivery,
		arg.WebhookID,
		arg.Event,
		arg.Payload,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i WebhookDelivery
	err := row.Scan(
		&i.ID,
		&i.WebhookID,
		&i.Event,
		&i.Payload,
		&i.ResponseCode,
		&i.ResponseBody,
		&i.Attempts,
		&i.NextRetryAt,
		&i.DeliveredAt,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOldDeliveries = `-- name: DeleteOldDeliveries :exec
DELETE FROM webhook_deliveries WHERE created_at < ? AND status IN ('delivered', 'dead')
`

func (q *Queries) DeleteOldDeliveries(ctx context.Context, createdAt time.Time) error {
	_, err := q.db.ExecContext(ctx, deleteOldDeliveries, createdAt)
	return err
}

const deleteWebhook = `-- name: DeleteWebhook :exec
DELETE FROM webhooks WHERE id = ?
`

func (q *Queries) DeleteWebhook(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteWebhook, id)
	return err
}

const getDeliveryStats = `-- name: GetDeliveryStats :one
SELECT
    COUNT(*) as total,
    SUM(CASE WHEN status = 'delivered' THEN 1 ELSE 0 END) as delivered,
    SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
    SUM(CASE WHEN status = 'dead' THEN 1 ELSE 0 END) as dead
FROM webhook_deliveries WHERE webhook_id = ?
`

type GetDeliveryStatsRow struct {
	Total     int64           `json:"total"`
	Delivered sql.NullFloat64 `json:"delivered"`
	Pending   sql.NullFloat64 `json:"pending"`
	Dead      sql.NullFloat64 `json:"dead"`
}

func (q *Queries) GetDeliveryStats(ctx context.Context, webhookID int64) (GetDeliveryStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getDeliveryStats, webhookID)
	var i GetDeliveryStatsRow
	err := row.Scan(
		&i.Total,
		&i.Delivered,
		&i.Pending,
		&i.Dead,
	)
	return i, err
}

const getDeliveryStatsLast24h = `-- name: GetDeliveryStatsLast24h :one
SELECT
    COUNT(*) as total,
    SUM(CASE WHEN status = 'delivered' THEN 1 ELSE 0 END) as delivered,
    SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
    SUM(CASE WHEN status = 'dead' THEN 1 ELSE 0 END) as dead
FROM webhook_deliveries
WHERE webhook_id = ? AND created_at >= ?
`

type GetDeliveryStatsLast24hParams struct {
	WebhookID int64     `json:"webhook_id"`
	CreatedAt time.Time `json:"created_at"`
}

type GetDeliveryStatsLast24hRow struct {
	Total     int64           `json:"total"`
	Delivered sql.NullFloat64 `json:"delivered"`
	Pending   sql.NullFloat64 `json:"pending"`
	Dead      sql.NullFloat64 `json:"dead"`
}

func (q *Queries) GetDeliveryStatsLast24h(ctx context.Context, arg GetDeliveryStatsLast24hParams) (GetDeliveryStatsLast24hRow, error) {
	row := q.db.QueryRowContext(ctx, getDeliveryStatsLast24h, arg.WebhookID, arg.CreatedAt)
	var i GetDeliveryStatsLast24hRow
	err := row.Scan(
		&i.Total,
		&i.Delivered,
		&i.Pending,
		&i.Dead,
	)
	return i, err
}

const getLastSuccessfulDelivery = `-- name: GetLastSuccessfulDelivery :one
SELECT id, webhook_id, event, payload, response_code, response_body, attempts, next_retry_at, delivered_at, status, error_message, created_at, updated_at FROM webhook_deliveries
WHERE webhook_id = ? AND status = 'delivered'
ORDER BY delivered_at DESC LIMIT 1
`

func (q *Queries) GetLastSuccessfulDelivery(ctx context.Context, webhookID int64) (WebhookDelivery, error) {
	row := q.db.QueryRowContext(ctx, getLastSuccessfulDelivery, webhookID)
	var i WebhookDelivery
	err := row.Scan(
		&i.ID,
		&i.WebhookID,
		&i.Event,
		&i.Payload,
		&i.ResponseCode,
		&i.ResponseBody,
		&i.Attempts,
		&i.NextRetryAt,
		&i.DeliveredAt,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPendingDeliveries = `-- name: GetPendingDeliveries :many
SELECT id, webhook_id, event, payload, response_code, response_body, attempts, next_retry_at, delivered_at, status, error_message, created_at, updated_at FROM webhook_deliveries
WHERE status = 'pending' AND (next_retry_at IS NULL OR next_retry_at <= ?)
ORDER BY created_at LIMIT ?
`

type GetPendingDeliveriesParams struct {
	NextRetryAt sql.NullTime `json:"next_retry_at"`
	Limit       int64        `json:"limit"`
}

func (q *Queries) GetPendingDeliveries(ctx context.Context, arg GetPendingDeliveriesParams) ([]WebhookDelivery, error) {
	rows, err := q.db.QueryContext(ctx, getPendingDeliveries, arg.NextRetryAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookDelivery{}
	for rows.Next() {
		var i WebhookDelivery
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.Event,
			&i.Payload,
			&i.ResponseCode,
			&i.ResponseBody,
			&i.Attempts,
			&i.NextRetryAt,
			&i.DeliveredAt,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentDeliveries = `-- name: GetRecentDeliveries :many
SELECT id, webhook_id, event, payload, response_code, response_body, attempts, next_retry_at, delivered_at, status, error_message, created_at, updated_at FROM webhook_deliveries
ORDER BY created_at DESC LIMIT ?
`

func (q *Queries) GetRecentDeliveries(ctx context.Context, limit int64) ([]WebhookDelivery, error) {
	rows, err := q.db.QueryContext(ctx, getRecentDeliveries, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookDelivery{}
	for rows.Next() {
		var i WebhookDelivery
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.Event,
			&i.Payload,
			&i.ResponseCode,
			&i.ResponseBody,
			&i.Attempts,
			&i.NextRetryAt,
			&i.DeliveredAt,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentFailedDeliveries = `-- name: GetRecentFailedDeliveries :many
SELECT id, webhook_id, event, payload, response_code, response_body, attempts, next_retry_at, delivered_at, status, error_message, created_at, updated_at FROM webhook_deliveries
WHERE status IN ('failed', 'dead')
ORDER BY created_at DESC LIMIT ?
`

func (q *Queries) GetRecentFailedDeliveries(ctx context.Context, limit int64) ([]WebhookDelivery, error) {
	rows, err := q.db.QueryContext(ctx, getRecentFailedDeliveries, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookDelivery{}
	for rows.Next() {
		var i WebhookDelivery
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.Event,
			&i.Payload,
			&i.ResponseCode,
			&i.ResponseBody,
			&i.Attempts,
			&i.NextRetryAt,
			&i.DeliveredAt,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentFailedDeliveriesWithWebhook = `-- name: GetRecentFailedDeliveriesWithWebhook :many
SELECT
    wd.id, wd.webhook_id, wd.event, wd.payload, wd.response_code, wd.response_body, wd.attempts, wd.next_retry_at, wd.delivered_at, wd.status, wd.error_message, wd.created_at, wd.updated_at,
    w.name as webhook_name
FROM webhook_deliveries wd
INNER JOIN webhooks w ON w.id = wd.webhook_id
WHERE wd.status IN ('dead', 'failed')
ORDER BY wd.created_at DESC LIMIT ?
`

type GetRecentFailedDeliveriesWithWebhookRow struct {
	ID           int64          `json:"id"`
	WebhookID    int64          `json:"webhook_id"`
	Event        string         `json:"event"`
	Payload      string         `json:"payload"`
	ResponseCode sql.NullInt64  `json:"response_code"`
	ResponseBody sql.NullString `json:"response_body"`
	Attempts     int64          `json:"attempts"`
	NextRetryAt  sql.NullTime   `json:"next_retry_at"`
	DeliveredAt  sql.NullTime   `json:"delivered_at"`
	Status       string         `json:"status"`
	ErrorMessage sql.NullString `json:"error_message"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	WebhookName  string         `json:"webhook_name"`
}

func (q *Queries) GetRecentFailedDeliveriesWithWebhook(ctx context.Context, limit int64) ([]GetRecentFailedDeliveriesWithWebhookRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentFailedDeliveriesWithWebhook, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentFailedDeliveriesWithWebhookRow{}
	for rows.Next() {
		var i GetRecentFailedDeliveriesWithWebhookRow
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.Event,
			&i.Payload,
			&i.ResponseCode,
			&i.ResponseBody,
			&i.Attempts,
			&i.NextRetryAt,
			&i.DeliveredAt,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.WebhookName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebhookByID = `-- name: GetWebhookByID :one
SELECT id, name, url, secret, events, is_active, headers, created_by, created_at, updated_at FROM webhooks WHERE id = ?
`

func (q *Queries) GetWebhookByID(ctx context.Context, id int64) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, getWebhookByID, id)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Secret,
		&i.Events,
		&i.IsActive,
		&i.Headers,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWebhookDelivery = `-- name: GetWebhookDelivery :one
SELECT id, webhook_id, event, payload, response_code, response_body, attempts, next_retry_at, delivered_at, status, error_message, created_at, updated_at FROM webhook_deliveries WHERE id = ?
`

func (q *Queries) GetWebhookDelivery(ctx context.Context, id int64) (WebhookDelivery, error) {
	row := q.db.QueryRowContext(ctx, getWebhookDelivery, id)
	var i WebhookDelivery
	err := row.Scan(
		&i.ID,
		&i.WebhookID,
		&i.Event,
		&i.Payload,
		&i.ResponseCode,
		&i.ResponseBody,
		&i.Attempts,
		&i.NextRetryAt,
		&i.DeliveredAt,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWebhookHealthSummary = `-- name: GetWebhookHealthSummary :many
SELECT
    w.id,
    w.name,
    w.is_active,
    COUNT(wd.id) as total_deliveries,
    SUM(CASE WHEN wd.status = 'delivered' THEN 1 ELSE 0 END) as delivered_count,
    SUM(CASE WHEN wd.status = 'pending' THEN 1 ELSE 0 END) as pending_count,
    SUM(CASE WHEN wd.status = 'dead' THEN 1 ELSE 0 END) as dead_count
FROM webhooks w
LEFT JOIN webhook_deliveries wd ON wd.webhook_id = w.id AND wd.created_at >= ?
GROUP BY w.id, w.name, w.is_active
ORDER BY w.name
`

type GetWebhookHealthSummaryRow struct {
	ID              int64           `json:"id"`
	Name            string          `json:"name"`
	IsActive        bool            `json:"is_active"`
	TotalDeliveries int64           `json:"total_deliveries"`
	DeliveredCount  sql.NullFloat64 `json:"delivered_count"`
	PendingCount    sql.NullFloat64 `json:"pending_count"`
	DeadCount       sql.NullFloat64 `json:"dead_count"`
}

func (q *Queries) GetWebhookHealthSummary(ctx context.Context, createdAt time.Time) ([]GetWebhookHealthSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getWebhookHealthSummary, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWebhookHealthSummaryRow{}
	for rows.Next() {
		var i GetWebhookHealthSummaryRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IsActive,
			&i.TotalDeliveries,
			&i.DeliveredCount,
			&i.PendingCount,
			&i.DeadCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveWebhooks = `-- name: ListActiveWebhooks :many
SELECT id, name, url, secret, events, is_active, headers, created_by, created_at, updated_at FROM webhooks WHERE is_active = 1 ORDER BY name
`

func (q *Queries) ListActiveWebhooks(ctx context.Context) ([]Webhook, error) {
	rows, err := q.db.QueryContext(ctx, listActiveWebhooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Webhook{}
	for rows.Next() {
		var i Webhook
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Url,
			&i.Secret,
			&i.Events,
			&i.IsActive,
			&i.Headers,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhookDeliveries = `-- name: ListWebhookDeliveries :many
SELECT id, webhook_id, event, payload, response_code, response_body, attempts, next_retry_at, delivered_at, status, error_message, created_at, updated_at FROM webhook_deliveries WHERE webhook_id = ?
ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListWebhookDeliveriesParams struct {
	WebhookID int64 `json:"webhook_id"`
	Limit     int64 `json:"limit"`
	Offset    int64 `json:"offset"`
}

func (q *Queries) ListWebhookDeliveries(ctx context.Context, arg ListWebhookDeliveriesParams) ([]WebhookDelivery, error) {
	rows, err := q.db.QueryContext(ctx, listWebhookDeliveries, arg.WebhookID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WebhookDelivery{}
	for rows.Next() {
		var i WebhookDelivery
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.Event,
			&i.Payload,
			&i.ResponseCode,
			&i.ResponseBody,
			&i.Attempts,
			&i.NextRetryAt,
			&i.DeliveredAt,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhooks = `-- name: ListWebhooks :many
SELECT id, name, url, secret, events, is_active, headers, created_by, created_at, updated_at FROM webhooks ORDER BY name
`

func (q *Queries) ListWebhooks(ctx context.Context) ([]Webhook, error) {
	rows, err := q.db.QueryContext(ctx, listWebhooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Webhook{}
	for rows.Next() {
		var i Webhook
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Url,
			&i.Secret,
			&i.Events,
			&i.IsActive,
			&i.Headers,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhooksForEvent = `-- name: ListWebhooksForEvent :many
SELECT id, name, url, secret, events, is_active, headers, created_by, created_at, updated_at FROM webhooks
WHERE is_active = 1 AND events LIKE '%' || ? || '%'
`

func (q *Queries) ListWebhooksForEvent(ctx context.Context, dollar_1 sql.NullString) ([]Webhook, error) {
	rows, err := q.db.QueryContext(ctx, listWebhooksForEvent, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Webhook{}
	for rows.Next() {
		var i Webhook
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Url,
			&i.Secret,
			&i.Events,
			&i.IsActive,
			&i.Headers,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhooksPaginated = `-- name: ListWebhooksPaginated :many
SELECT id, name, url, secret, events, is_active, headers, created_by, created_at, updated_at FROM webhooks ORDER BY name LIMIT ? OFFSET ?
`

type ListWebhooksPaginatedParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListWebhooksPaginated(ctx context.Context, arg ListWebhooksPaginatedParams) ([]Webhook, error) {
	rows, err := q.db.QueryContext(ctx, listWebhooksPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Webhook{}
	for rows.Next() {
		var i Webhook
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Url,
			&i.Secret,
			&i.Events,
			&i.IsActive,
			&i.Headers,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetDeliveryForRetry = `-- name: ResetDeliveryForRetry :exec
UPDATE webhook_deliveries
SET status = 'pending', attempts = 0, next_retry_at = NULL, error_message = '', updated_at = ?
WHERE id = ?
`

type ResetDeliveryForRetryParams struct {
	UpdatedAt time.Time `json:"updated_at"`
	ID        int64     `json:"id"`
}

func (q *Queries) ResetDeliveryForRetry(ctx context.Context, arg ResetDeliveryForRetryParams) error {
	_, err := q.db.ExecContext(ctx, resetDeliveryForRetry, arg.UpdatedAt, arg.ID)
	return err
}

const updateDeliveryDead = `-- name: UpdateDeliveryDead :exec
UPDATE webhook_deliveries
SET status = 'dead', error_message = ?, attempts = attempts + 1, updated_at = ?
WHERE id = ?
`

type UpdateDeliveryDeadParams struct {
	ErrorMessage sql.NullString `json:"error_message"`
	UpdatedAt    time.Time      `json:"updated_at"`
	ID           int64          `json:"id"`
}

func (q *Queries) UpdateDeliveryDead(ctx context.Context, arg UpdateDeliveryDeadParams) error {
	_, err := q.db.ExecContext(ctx, updateDeliveryDead, arg.ErrorMessage, arg.UpdatedAt, arg.ID)
	return err
}

const updateDeliveryRetry = `-- name: UpdateDeliveryRetry :exec
UPDATE webhook_deliveries
SET status = 'pending', response_code = ?, response_body = ?, error_message = ?, attempts = attempts + 1, next_retry_at = ?, updated_at = ?
WHERE id = ?
`

type UpdateDeliveryRetryParams struct {
	ResponseCode sql.NullInt64  `json:"response_code"`
	ResponseBody sql.NullString `json:"response_body"`
	ErrorMessage sql.NullString `json:"error_message"`
	NextRetryAt  sql.NullTime   `json:"next_retry_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	ID           int64          `json:"id"`
}

func (q *Queries) UpdateDeliveryRetry(ctx context.Context, arg UpdateDeliveryRetryParams) error {
	_, err := q.db.ExecContext(ctx, updateDeliveryRetry,
		arg.ResponseCode,
		arg.ResponseBody,
		arg.ErrorMessage,
		arg.NextRetryAt,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateDeliverySuccess = `-- name: UpdateDeliverySuccess :exec
UPDATE webhook_deliveries
SET status = 'delivered', response_code = ?, response_body = ?, delivered_at = ?, attempts = attempts + 1, updated_at = ?
WHERE id = ?
`

type UpdateDeliverySuccessParams struct {
	ResponseCode sql.NullInt64  `json:"response_code"`
	ResponseBody sql.NullString `json:"response_body"`
	DeliveredAt  sql.NullTime   `json:"delivered_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	ID           int64          `json:"id"`
}

func (q *Queries) UpdateDeliverySuccess(ctx context.Context, arg UpdateDeliverySuccessParams) error {
	_, err := q.db.ExecContext(ctx, updateDeliverySuccess,
		arg.ResponseCode,
		arg.ResponseBody,
		arg.DeliveredAt,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateWebhook = `-- name: UpdateWebhook :one
UPDATE webhooks SET name = ?, url = ?, secret = ?, events = ?, is_active = ?, headers = ?, updated_at = ?
WHERE id = ?
RETURNING id, name, url, secret, events, is_active, headers, created_by, created_at, updated_at
`

type UpdateWebhookParams struct {
	Name      string    `json:"name"`
	Url       string    `json:"url"`
	Secret    string    `json:"secret"`
	Events    string    `json:"events"`
	IsActive  bool      `json:"is_active"`
	Headers   string    `json:"headers"`
	UpdatedAt time.Time `json:"updated_at"`
	ID        int64     `json:"id"`
}

func (q *Queries) UpdateWebhook(ctx context.Context, arg UpdateWebhookParams) (Webhook, error) {
	row := q.db.QueryRowContext(ctx, updateWebhook,
		arg.Name,
		arg.Url,
		arg.Secret,
		arg.Events,
		arg.IsActive,
		arg.Headers,
		arg.UpdatedAt,
		arg.ID,
	)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Secret,
		&i.Events,
		&i.IsActive,
		&i.Headers,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
