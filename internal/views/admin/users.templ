// Copyright (c) 2025-2026 Oleg Ivanchenko
// SPDX-License-Identifier: GPL-3.0-or-later

package admin

import (
	"fmt"
	"time"
	"github.com/olegiv/ocms-go/internal/views/components/button"
	"github.com/olegiv/ocms-go/internal/views/components/icon"
	"github.com/olegiv/ocms-go/internal/views/components/badge"
	"github.com/olegiv/ocms-go/internal/views/components/card"
	"github.com/olegiv/ocms-go/internal/views/components/table"
	"github.com/olegiv/ocms-go/internal/views/components/input"
	"github.com/olegiv/ocms-go/internal/views/components/label"
)

// UserListItem holds data for a user in the list view.
type UserListItem struct {
	ID            int64
	Name          string
	Email         string
	Role          string
	CreatedAt     time.Time
	LastLoginAt   *time.Time
	IsCurrentUser bool
}

// UsersListData holds all data for the users list page.
type UsersListData struct {
	Users      []UserListItem
	TotalCount int64
	Pagination PaginationData
}

// UserFormData holds all data for the user create/edit form.
type UserFormData struct {
	IsEdit     bool
	User       *UserItem
	Roles      []string
	FormValues map[string]string
	Errors     map[string]string
}

// UserItem holds individual user data.
type UserItem struct {
	ID    int64
	Name  string
	Email string
	Role  string
}

// UsersListPage renders the users list page.
templ UsersListPage(pc *PageContext, data UsersListData) {
	@AdminLayout(pc) {
		@PageHeader(pc.T("users.title"), pc.T("users.description", data.TotalCount)) {
			@button.Button(button.Props{Href: "/admin/users/new"}) {
				@icon.Users(icon.Props{Size: 16})
				{ pc.T("users.add_user") }
			}
		}
		if len(data.Users) > 0 {
			@card.Card(card.Props{ID: "users-table"}) {
				@card.Content(card.ContentProps{Class: "p-0"}) {
					<div class="overflow-x-auto">
						@table.Table() {
							@table.Header() {
								@table.Row() {
									@table.Head() { { pc.T("label.name") } }
									@table.Head() { { pc.T("label.email") } }
									@table.Head() { { pc.T("label.role") } }
									@table.Head() { { pc.T("label.created_at") } }
									@table.Head() { { pc.T("users.last_login") } }
									@table.Head(table.HeadProps{Class: "text-right"}) { { pc.T("label.actions") } }
								}
							}
							@table.Body() {
								for _, user := range data.Users {
									@table.Row(table.RowProps{ID: fmt.Sprintf("user-row-%d", user.ID)}) {
										@table.Cell() {
											<div class="user-cell">
												<div class="user-avatar-sm">{ string(user.Name[0]) }</div>
												<span>{ user.Name }</span>
												if user.IsCurrentUser {
													@badge.Badge(badge.Props{Class: "badge-info"}) {
														{ pc.T("users.you") }
													}
												}
											</div>
										}
										@table.Cell() { { user.Email } }
										@table.Cell() {
											@badge.Badge(badge.Props{Class: roleBadgeClass(user.Role)}) {
												{ roleLabel(pc, user.Role) }
											}
										}
										@table.Cell() { { user.CreatedAt.Format("Jan 02, 2006") } }
										@table.Cell() {
											if user.LastLoginAt != nil {
												{ user.LastLoginAt.Format("Jan 02, 2006 15:04") }
											} else {
												<span class="text-muted">{ pc.T("users.never") }</span>
											}
										}
										@table.Cell(table.CellProps{Class: "text-right"}) {
											<div class="action-buttons">
												@button.Button(button.Props{Variant: button.VariantOutline, Size: button.SizeSm, Href: fmt.Sprintf("/admin/users/%d", user.ID), Attributes: templ.Attributes{"title": pc.T("btn.edit")}}) {
													@icon.Pencil(icon.Props{Size: 14})
												}
												if !user.IsCurrentUser {
													@deleteUserModal(pc, user)
												}
											</div>
										}
									}
								}
							}
						}
					</div>
				}
				if data.Pagination.ShouldShow() {
					@card.Footer() {
						@Pagination(pc, data.Pagination)
					}
				}
			}
		} else {
			@card.Card() {
				@card.Content() {
					<div class="empty-state">
						<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>
						<p>{ pc.T("users.no_users") }</p>
						<span class="empty-hint">{ pc.T("users.create_first_hint") }</span>
						<div class="empty-state-action">
							@button.Button(button.Props{Href: "/admin/users/new"}) {
								{ pc.T("users.add_user") }
							}
						</div>
					</div>
				}
			}
		}
	}
}

templ deleteUserModal(pc *PageContext, user UserListItem) {
	<div x-data="{ showConfirm: false }" class="delete-action">
		@button.Button(button.Props{Variant: button.VariantDestructive, Size: button.SizeSm, Attributes: templ.Attributes{"title": pc.T("btn.delete"), "@click": "showConfirm = true"}}) {
			@icon.Trash2(icon.Props{Size: 14})
		}
		<div
			class="modal-overlay"
			x-show="showConfirm"
			x-cloak
			@click.self="showConfirm = false"
			x-transition:enter="modal-enter"
			x-transition:leave="modal-leave"
		>
			<div class="modal" @click.stop>
				<div class="modal-header">
					<h3 class="modal-title">{ pc.T("users.delete_user") }</h3>
					<button type="button" class="modal-close" @click="showConfirm = false" aria-label={ pc.T("btn.close") }>&times;</button>
				</div>
				<div class="modal-body">
					<p>{ pc.T("users.confirm_delete") }</p>
					<p class="text-muted">{ pc.T("users.delete_warning") }</p>
				</div>
				<div class="modal-footer">
					@button.Button(button.Props{Variant: button.VariantOutline, Attributes: templ.Attributes{"@click": "showConfirm = false"}}) {
						{ pc.T("btn.cancel") }
					}
					@button.Button(button.Props{Variant: button.VariantDestructive, Attributes: templ.Attributes{"hx-delete": fmt.Sprintf("/admin/users/%d", user.ID), "hx-target": fmt.Sprintf("#user-row-%d", user.ID), "hx-swap": "outerHTML", "@click": "showConfirm = false"}}) {
						{ pc.T("users.delete_user") }
					}
				</div>
			</div>
		</div>
	</div>
}

// UserFormPage renders the user create/edit form.
templ UserFormPage(pc *PageContext, data UserFormData) {
	@AdminLayout(pc) {
		@PageHeader(userFormTitle(pc, data.IsEdit), userFormDescription(pc, data.IsEdit)) {
			@button.Button(button.Props{Variant: button.VariantOutline, Href: "/admin/users"}) {
				@icon.ArrowLeft(icon.Props{Size: 16})
				{ pc.T("users.back_to_users") }
			}
		}
		@card.Card() {
			<form
				id="user-form"
				method="POST"
				action={ userFormAction(data) }
				class="p-6"
			>
				if data.IsEdit {
					<input type="hidden" name="_method" value="PUT"/>
				}
				<div class="form-grid">
					<!-- Name -->
					<div class="form-group">
						@label.Label(label.Props{For: "name", Class: "block mb-1"}) {
							{ pc.T("label.name") } <span class="required">*</span>
						}
						@input.Input(input.Props{
							ID: "name",
							Name: "name",
							Value: userFormValue(data, "name"),
							Placeholder: pc.T("users.name_placeholder"),
							HasError: data.Errors["name"] != "",
							Attributes: templ.Attributes{
								"required": true,
								"autofocus": true,
								"maxlength": "255",
							},
						})
						if data.Errors["name"] != "" {
							<span class="form-error">{ data.Errors["name"] }</span>
						}
					</div>
					<!-- Email -->
					<div class="form-group">
						@label.Label(label.Props{For: "email", Class: "block mb-1"}) {
							{ pc.T("label.email") } <span class="required">*</span>
						}
						@input.Input(input.Props{
							Type: input.TypeEmail,
							ID: "email",
							Name: "email",
							Value: userFormValue(data, "email"),
							Placeholder: pc.T("users.email_placeholder"),
							HasError: data.Errors["email"] != "",
							Attributes: templ.Attributes{
								"required": true,
								"maxlength": "255",
							},
						})
						if data.Errors["email"] != "" {
							<span class="form-error">{ data.Errors["email"] }</span>
						}
					</div>
					<!-- Role -->
					<div class="form-group">
						@label.Label(label.Props{For: "role", Class: "block mb-1"}) {
							{ pc.T("label.role") } <span class="required">*</span>
						}
						<select
							id="role"
							name="role"
							class={ templ.KV("form-input form-select", true), templ.KV("is-invalid", data.Errors["role"] != "") }
							required
						>
							<option value="">{ pc.T("users.select_role") }</option>
							for _, role := range data.Roles {
								<option value={ role } selected?={ role == userFormValue(data, "role") }>
									{ roleLabel(pc, role) }
								</option>
							}
						</select>
						if data.Errors["role"] != "" {
							<span class="form-error">{ data.Errors["role"] }</span>
						}
					</div>
					<!-- Password Section -->
					<div class="form-group form-group-full">
						<hr class="form-divider"/>
						<h3 class="form-section-title">
							if data.IsEdit {
								{ pc.T("users.change_password") }
							} else {
								{ pc.T("users.password_section") }
							}
						</h3>
						if data.IsEdit {
							<p class="form-help">{ pc.T("users.password_keep_hint") }</p>
						}
					</div>
					<!-- Password -->
					<div class="form-group" x-data="passwordStrength()">
						@label.Label(label.Props{For: "password", Class: "block mb-1"}) {
							{ pc.T("label.password") }
							if !data.IsEdit {
								<span class="required">*</span>
							}
						}
						@input.Input(input.Props{
							Type: input.TypePassword,
							NoTogglePassword: true,
							ID: "password",
							Name: "password",
							Placeholder: passwordPlaceholder(pc, data.IsEdit),
							HasError: data.Errors["password"] != "",
							Attributes: templ.Attributes{
								"minlength": "12",
								"required": !data.IsEdit,
								"x-model": "password",
								"@input": "checkStrength()",
							},
						})
						<div class="password-strength" x-show="password.length > 0">
							<div class="password-strength-bar">
								<div class="password-strength-fill" :class="strengthClass" :style="'width: ' + strengthPercent + '%'"></div>
							</div>
							<span class="password-strength-text" :class="strengthClass" x-text="strengthText"></span>
						</div>
						if data.Errors["password"] != "" {
							<span class="form-error">{ data.Errors["password"] }</span>
						} else {
							<span class="form-hint">{ pc.T("users.password_min_hint") }</span>
						}
					</div>
					<!-- Confirm Password -->
					<div class="form-group">
						@label.Label(label.Props{For: "password_confirm", Class: "block mb-1"}) {
							{ pc.T("label.confirm_password") }
							if !data.IsEdit {
								<span class="required">*</span>
							}
						}
						@input.Input(input.Props{
							Type: input.TypePassword,
							NoTogglePassword: true,
							ID: "password_confirm",
							Name: "password_confirm",
							Placeholder: pc.T("users.confirm_password_placeholder"),
							HasError: data.Errors["password_confirm"] != "",
							Attributes: templ.Attributes{
								"minlength": "12",
								"required": !data.IsEdit,
							},
						})
						if data.Errors["password_confirm"] != "" {
							<span class="form-error">{ data.Errors["password_confirm"] }</span>
						}
					</div>
				</div>
				<div class="form-actions">
					@button.Button(button.Props{Type: button.TypeSubmit}) {
						if data.IsEdit {
							@icon.Save(icon.Props{Size: 16})
							{ pc.T("users.update") }
						} else {
							@icon.Users(icon.Props{Size: 16})
							{ pc.T("users.create") }
						}
					}
					@button.Button(button.Props{Variant: button.VariantOutline, Href: "/admin/users"}) {
						{ pc.T("btn.cancel") }
					}
				</div>
			</form>
		}
	}
}

// Helper functions

func userFormAction(data UserFormData) templ.SafeURL {
	if data.IsEdit && data.User != nil {
		return templ.SafeURL(fmt.Sprintf("/admin/users/%d", data.User.ID))
	}
	return "/admin/users"
}

func userFormValue(data UserFormData, field string) string {
	if v, ok := data.FormValues[field]; ok && v != "" {
		return v
	}
	if data.User != nil {
		switch field {
		case "name":
			return data.User.Name
		case "email":
			return data.User.Email
		case "role":
			return data.User.Role
		}
	}
	return ""
}

func roleBadgeClass(role string) string {
	switch role {
	case "admin":
		return "badge-primary"
	case "editor":
		return "badge-success"
	default:
		return "badge-secondary"
	}
}

func roleLabel(pc *PageContext, role string) string {
	switch role {
	case "admin":
		return pc.T("users.role_admin")
	case "editor":
		return pc.T("users.role_editor")
	case "public":
		return pc.T("users.role_public")
	default:
		return role
	}
}

func passwordPlaceholder(pc *PageContext, isEdit bool) string {
	if isEdit {
		return pc.T("users.new_password_placeholder")
	}
	return pc.T("users.password_placeholder")
}

func userFormTitle(pc *PageContext, isEdit bool) string {
	if isEdit {
		return pc.T("users.edit")
	}
	return pc.T("users.new")
}

func userFormDescription(pc *PageContext, isEdit bool) string {
	if isEdit {
		return pc.T("users.edit_description")
	}
	return pc.T("users.new_description")
}
