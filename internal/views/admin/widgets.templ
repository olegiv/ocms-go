// Copyright (c) 2025-2026 Oleg Ivanchenko
// SPDX-License-Identifier: GPL-3.0-or-later

package admin

import "fmt"
import "encoding/json"

// WidgetTypeView represents a widget type option.
type WidgetTypeView struct {
	ID          string
	Name        string
	Description string
}

// WidgetItemView represents a single widget in a widget area.
type WidgetItemView struct {
	ID         int64
	WidgetType string
	Title      string
	HasTitle   bool
}

// WidgetAreaView represents a widget area with its widgets.
type WidgetAreaView struct {
	AreaID          string
	AreaName        string
	AreaDescription string
	Widgets         []WidgetItemView
}

// WidgetsViewData holds all data for the widgets list page.
type WidgetsViewData struct {
	ThemeName   string
	WidgetAreas []WidgetAreaView
	WidgetTypes []WidgetTypeView
}

func widgetTypesJSON(types []WidgetTypeView) string {
	b, _ := json.Marshal(types)
	return string(b)
}

templ WidgetsPage(pc *PageContext, data WidgetsViewData) {
	@AdminLayout(pc) {
		<div class="mb-8 flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
			<div>
				<h1 class="text-2xl font-bold text-gray-900 dark:text-white">Widgets</h1>
				<p class="mt-1 text-sm text-gray-500 dark:text-gray-400">
					Manage widgets for <strong>{ data.ThemeName }</strong> theme
				</p>
			</div>
		</div>
		if len(data.WidgetAreas) > 0 {
			<div x-data="widgetsManager()">
				<div class="grid grid-cols-1 gap-6 lg:grid-cols-2">
					for _, area := range data.WidgetAreas {
						<div class="rounded-lg border border-gray-200 bg-white shadow-sm dark:border-gray-700 dark:bg-gray-800">
							<div class="border-b border-gray-200 p-4 dark:border-gray-700">
								<h3 class="text-lg font-semibold text-gray-900 dark:text-white">{ area.AreaName }</h3>
								if area.AreaDescription != "" {
									<p class="mt-1 text-sm text-gray-500 dark:text-gray-400">{ area.AreaDescription }</p>
								}
							</div>
							<div class="p-4" data-area={ area.AreaID }>
								if len(area.Widgets) > 0 {
									<div class="space-y-2">
										for _, widget := range area.Widgets {
											<div class="flex items-center justify-between rounded-md border border-gray-200 bg-gray-50 px-3 py-2 dark:border-gray-600 dark:bg-gray-700" data-widget-id={ fmt.Sprint(widget.ID) } id={ fmt.Sprintf("widget-%d", widget.ID) }>
												<div class="flex items-center gap-2">
													<span class="cursor-grab text-gray-400">
														@iconGripVertical()
													</span>
													<span class="rounded bg-indigo-100 px-2 py-0.5 text-xs font-medium text-indigo-800 dark:bg-indigo-900 dark:text-indigo-200">{ widget.WidgetType }</span>
													if widget.HasTitle {
														<span class="text-sm text-gray-700 dark:text-gray-300">{ widget.Title }</span>
													}
												</div>
												<div class="flex items-center gap-1">
													<button type="button" class="rounded p-1 text-gray-400 hover:bg-gray-200 hover:text-gray-600 dark:hover:bg-gray-600 dark:hover:text-gray-300" @click={ fmt.Sprintf("editWidget(%d)", widget.ID) } title="Edit">
														@iconEdit()
													</button>
													<button type="button" class="rounded p-1 text-gray-400 hover:bg-red-100 hover:text-red-600 dark:hover:bg-red-900 dark:hover:text-red-400" @click={ fmt.Sprintf("deleteWidget(%d)", widget.ID) } title="Delete">
														@iconTrash()
													</button>
												</div>
											</div>
										}
									</div>
								} else {
									<p class="py-4 text-center text-sm text-gray-500 dark:text-gray-400">No widgets in this area</p>
								}
								<button type="button" class="mt-3 flex w-full items-center justify-center gap-1 rounded-md border border-dashed border-gray-300 px-3 py-2 text-sm text-gray-500 hover:border-indigo-400 hover:text-indigo-600 dark:border-gray-600 dark:text-gray-400 dark:hover:border-indigo-500 dark:hover:text-indigo-400" @click={ fmt.Sprintf("openAddWidget('%s')", area.AreaID) }>
									@iconPlus()
									Add Widget
								</button>
							</div>
						</div>
					}
				</div>
				<!-- Add Widget Modal -->
				<div class="fixed inset-0 z-50 flex items-center justify-center bg-black/50" x-show="showAddModal" x-cloak @click.self="showAddModal = false">
					<div class="w-full max-w-md rounded-lg bg-white p-6 shadow-xl dark:bg-gray-800" @click.stop>
						<div class="mb-4 flex items-center justify-between">
							<h3 class="text-lg font-semibold text-gray-900 dark:text-white">Add Widget</h3>
							<button type="button" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300" @click="showAddModal = false">&times;</button>
						</div>
						<div class="space-y-4">
							<div>
								<label for="widget-type" class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300">Widget Type</label>
								<select id="widget-type" class="w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-sm dark:border-gray-600 dark:bg-gray-700 dark:text-white" x-model="newWidget.widget_type">
									<option value="">Select a widget type...</option>
									for _, wt := range data.WidgetTypes {
										<option value={ wt.ID }>{ wt.Name } - { wt.Description }</option>
									}
								</select>
							</div>
							<div>
								<label for="widget-title" class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300">Title (optional)</label>
								<input type="text" id="widget-title" class="w-full rounded-md border border-gray-300 px-3 py-2 text-sm dark:border-gray-600 dark:bg-gray-700 dark:text-white" x-model="newWidget.title" placeholder="Widget title" maxlength="255"/>
							</div>
							<div x-show="newWidget.widget_type === 'text'">
								<label for="widget-content" class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300">Content</label>
								<textarea id="widget-content" class="w-full rounded-md border border-gray-300 px-3 py-2 text-sm dark:border-gray-600 dark:bg-gray-700 dark:text-white" rows="5" x-model="newWidget.content" placeholder="HTML content..."></textarea>
							</div>
						</div>
						<div class="mt-6 flex justify-end gap-2">
							<button type="button" class="rounded-md border border-gray-300 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50 dark:border-gray-600 dark:text-gray-300 dark:hover:bg-gray-700" @click="showAddModal = false">Cancel</button>
							<button type="button" class="rounded-md bg-indigo-600 px-4 py-2 text-sm font-medium text-white hover:bg-indigo-700 disabled:opacity-50" @click="addWidget()" :disabled="!newWidget.widget_type">Add Widget</button>
						</div>
					</div>
				</div>
				<!-- Edit Widget Modal -->
				<div class="fixed inset-0 z-50 flex items-center justify-center bg-black/50" x-show="showEditModal" x-cloak @click.self="showEditModal = false">
					<div class="w-full max-w-md rounded-lg bg-white p-6 shadow-xl dark:bg-gray-800" @click.stop>
						<div class="mb-4 flex items-center justify-between">
							<h3 class="text-lg font-semibold text-gray-900 dark:text-white">Edit Widget</h3>
							<button type="button" class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300" @click="showEditModal = false">&times;</button>
						</div>
						<div class="space-y-4">
							<div>
								<label for="edit-widget-type" class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300">Widget Type</label>
								<select id="edit-widget-type" class="w-full rounded-md border border-gray-300 bg-white px-3 py-2 text-sm dark:border-gray-600 dark:bg-gray-700 dark:text-white" x-model="editingWidget.widget_type">
									for _, wt := range data.WidgetTypes {
										<option value={ wt.ID }>{ wt.Name }</option>
									}
								</select>
							</div>
							<div>
								<label for="edit-widget-title" class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300">Title</label>
								<input type="text" id="edit-widget-title" class="w-full rounded-md border border-gray-300 px-3 py-2 text-sm dark:border-gray-600 dark:bg-gray-700 dark:text-white" x-model="editingWidget.title" placeholder="Widget title" maxlength="255"/>
							</div>
							<div x-show="editingWidget.widget_type === 'text'">
								<label for="edit-widget-content" class="mb-1 block text-sm font-medium text-gray-700 dark:text-gray-300">Content</label>
								<textarea id="edit-widget-content" class="w-full rounded-md border border-gray-300 px-3 py-2 text-sm dark:border-gray-600 dark:bg-gray-700 dark:text-white" rows="5" x-model="editingWidget.content" placeholder="HTML content..."></textarea>
							</div>
							<div>
								<label class="flex items-center gap-2">
									<input type="checkbox" x-model="editingWidget.is_active" class="rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"/>
									<span class="text-sm text-gray-700 dark:text-gray-300">Active</span>
								</label>
							</div>
						</div>
						<div class="mt-6 flex justify-end gap-2">
							<button type="button" class="rounded-md border border-gray-300 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50 dark:border-gray-600 dark:text-gray-300 dark:hover:bg-gray-700" @click="showEditModal = false">Cancel</button>
							<button type="button" class="rounded-md bg-indigo-600 px-4 py-2 text-sm font-medium text-white hover:bg-indigo-700" @click="updateWidget()">Save Changes</button>
						</div>
					</div>
				</div>
				<script>
				function widgetsManager() {
					return {
						showAddModal: false,
						showEditModal: false,
						selectedArea: '',
						newWidget: { widget_type: '', title: '', content: '' },
						editingWidget: { id: 0, widget_type: '', title: '', content: '', is_active: true },
						openAddWidget(areaId) {
							this.selectedArea = areaId;
							this.newWidget = { widget_type: '', title: '', content: '' };
							this.showAddModal = true;
						},
						async addWidget() {
							try {
								const response = await fetch('/admin/widgets', {
									method: 'POST',
									headers: { 'Content-Type': 'application/json' },
									body: JSON.stringify({
										theme: this.$root.dataset.theme,
										area: this.selectedArea,
										widget_type: this.newWidget.widget_type,
										title: this.newWidget.title,
										content: this.newWidget.content
									})
								});
								if (response.ok) { location.reload(); } else { alert('Error adding widget'); }
							} catch (err) { console.error(err); alert('Error adding widget'); }
						},
						async editWidget(id) {
							try {
								const response = await fetch(`/admin/widgets/${id}`);
								if (response.ok) {
									const data = await response.json();
									const widget = data.data?.widget || data.widget;
									this.editingWidget = {
										id: widget.id,
										widget_type: widget.widget_type,
										title: widget.title?.String || '',
										content: widget.content?.String || '',
										is_active: widget.is_active === 1
									};
									this.showEditModal = true;
								}
							} catch (err) { console.error(err); alert('Error loading widget'); }
						},
						async updateWidget() {
							try {
								const response = await fetch(`/admin/widgets/${this.editingWidget.id}`, {
									method: 'PUT',
									headers: { 'Content-Type': 'application/json' },
									body: JSON.stringify({
										widget_type: this.editingWidget.widget_type,
										title: this.editingWidget.title,
										content: this.editingWidget.content,
										is_active: this.editingWidget.is_active
									})
								});
								if (response.ok) { location.reload(); } else { alert('Error updating widget'); }
							} catch (err) { console.error(err); alert('Error updating widget'); }
						},
						async deleteWidget(id) {
							if (!confirm('Are you sure you want to delete this widget?')) return;
							try {
								const response = await fetch(`/admin/widgets/${id}`, { method: 'DELETE' });
								if (response.ok) {
									document.getElementById(`widget-${id}`).remove();
								} else { alert('Error deleting widget'); }
							} catch (err) { console.error(err); alert('Error deleting widget'); }
						}
					};
				}
				</script>
			</div>
		} else {
			<div class="rounded-lg border border-gray-200 bg-white p-6 shadow-sm dark:border-gray-700 dark:bg-gray-800">
				<p class="text-gray-500 dark:text-gray-400">No widget areas defined for the current theme.</p>
				<p class="mt-1 text-sm text-gray-400 dark:text-gray-500">
					Widget areas are defined in the theme's <code class="rounded bg-gray-100 px-1 py-0.5 text-xs dark:bg-gray-700">theme.json</code> file.
				</p>
			</div>
		}
	}
}
